// Copyright 2022 The excelize Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.15 or later.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"reflect"
	"strconv"
	"syscall/js"

	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"

	_ "golang.org/x/image/tiff"

	"github.com/xuri/excelize/v2"
)

// argsRule represents the rule of the excelize wrapper function argument.
type argsRule struct {
	opts  bool
	types []js.Type
}

var (
	errArgNum  = errors.New("invalid arguments in call")
	errArgType = errors.New("invalid argument data type")
)

func main() {
	c := make(chan struct{})
	regFuncs()
	<-c
}

// regFuncs register all exported JavaScript functions on the Window ot Global.
func regFuncs() {
	for name, impl := range map[string]func(this js.Value, args []js.Value) interface{}{
		"CellNameToCoordinates": CellNameToCoordinates,
		"ColumnNameToNumber":    ColumnNameToNumber,
		"ColumnNumberToName":    ColumnNumberToName,
		"CoordinatesToCellName": CoordinatesToCellName,
		"HSLToRGB":              HSLToRGB,
		"JoinCellName":          JoinCellName,
		"RGBToHSL":              RGBToHSL,
		"SplitCellName":         SplitCellName,
		"ThemeColor":            ThemeColor,
		"NewFile":               NewFile,
		"OpenReader":            OpenReader,
	} {
		js.Global().Set(name, js.FuncOf(impl))
	}
}

// regInteropFunc register all exported JavaScript functions.
func regInteropFunc(f *excelize.File, fn map[string]interface{}) interface{} {
	for name, impl := range map[string]func(this js.Value, args []js.Value) interface{}{
		"AddChart":               AddChart(f),
		"AddChartSheet":          AddChartSheet(f),
		"AddComment":             AddComment(f),
		"AddPictureFromBytes":    AddPictureFromBytes(f),
		"AddPivotTable":          AddPivotTable(f),
		"AddShape":               AddShape(f),
		"AddTable":               AddTable(f),
		"AutoFilter":             AutoFilter(f),
		"CalcCellValue":          CalcCellValue(f),
		"CopySheet":              CopySheet(f),
		"DeleteChart":            DeleteChart(f),
		"DeleteComment":          DeleteComment(f),
		"DeleteDataValidation":   DeleteDataValidation(f),
		"DeletePicture":          DeletePicture(f),
		"DeleteSheet":            DeleteSheet(f),
		"DuplicateRow":           DuplicateRow(f),
		"DuplicateRowTo":         DuplicateRowTo(f),
		"GetActiveSheetIndex":    GetActiveSheetIndex(f),
		"GetAppProps":            GetAppProps(f),
		"GetCellFormula":         GetCellFormula(f),
		"GetCellHyperLink":       GetCellHyperLink(f),
		"GetCellStyle":           GetCellStyle(f),
		"GetCellValue":           GetCellValue(f),
		"GetColOutlineLevel":     GetColOutlineLevel(f),
		"GetColStyle":            GetColStyle(f),
		"GetColVisible":          GetColVisible(f),
		"GetColWidth":            GetColWidth(f),
		"GetCols":                GetCols(f),
		"GetRowHeight":           GetRowHeight(f),
		"GetRowOutlineLevel":     GetRowOutlineLevel(f),
		"GetRowVisible":          GetRowVisible(f),
		"GetRows":                GetRows(f),
		"GetSheetIndex":          GetSheetIndex(f),
		"GetSheetList":           GetSheetList(f),
		"GetSheetMap":            GetSheetMap(f),
		"GetSheetName":           GetSheetName(f),
		"GetSheetVisible":        GetSheetVisible(f),
		"GroupSheets":            GroupSheets(f),
		"InsertCols":             InsertCols(f),
		"InsertPageBreak":        InsertPageBreak(f),
		"InsertRows":             InsertRows(f),
		"MergeCell":              MergeCell(f),
		"NewConditionalStyle":    NewConditionalStyle(f),
		"NewSheet":               NewSheet(f),
		"NewStyle":               NewStyle(f),
		"RemoveCol":              RemoveCol(f),
		"RemovePageBreak":        RemovePageBreak(f),
		"RemoveRow":              RemoveRow(f),
		"SearchSheet":            SearchSheet(f),
		"SetActiveSheet":         SetActiveSheet(f),
		"SetCellBool":            SetCellBool(f),
		"SetCellDefault":         SetCellDefault(f),
		"SetCellFloat":           SetCellFloat(f),
		"SetCellInt":             SetCellInt(f),
		"SetCellStr":             SetCellStr(f),
		"SetCellStyle":           SetCellStyle(f),
		"SetCellValue":           SetCellValue(f),
		"SetColOutlineLevel":     SetColOutlineLevel(f),
		"SetColStyle":            SetColStyle(f),
		"SetColVisible":          SetColVisible(f),
		"SetColWidth":            SetColWidth(f),
		"SetConditionalFormat":   SetConditionalFormat(f),
		"SetDefaultFont":         SetDefaultFont(f),
		"SetPanes":               SetPanes(f),
		"SetRowHeight":           SetRowHeight(f),
		"SetRowOutlineLevel":     SetRowOutlineLevel(f),
		"SetRowStyle":            SetRowStyle(f),
		"SetRowVisible":          SetRowVisible(f),
		"SetSheetCol":            SetSheetCol(f),
		"SetSheetName":           SetSheetName(f),
		"SetSheetRow":            SetSheetRow(f),
		"SetSheetVisible":        SetSheetVisible(f),
		"UngroupSheets":          UngroupSheets(f),
		"UnmergeCell":            UnmergeCell(f),
		"UnprotectSheet":         UnprotectSheet(f),
		"UnsetConditionalFormat": UnsetConditionalFormat(f),
		"UpdateLinkedValue":      UpdateLinkedValue(f),
		"WriteToBuffer":          WriteToBuffer(f),
	} {
		fn[name] = js.FuncOf(impl)
	}
	return js.ValueOf(fn)
}

// inTypeSlice provides a method to check if an element is present in an
// JavaScript type value array, and return the index of its location,
// otherwise return -1.
func inTypeSlice(a []js.Type, x js.Type) int {
	for idx, n := range a {
		if x == n {
			return idx
		}
	}
	return -1
}

// prepareOptions provides a method to convert JavaScript type value to
// excelize options.
func prepareOptions(arg js.Value) (excelize.Options, error) {
	var opts excelize.Options
	passwd := arg.Get("password")
	if passwd.Type() != js.TypeUndefined {
		if passwd.Type() != js.TypeString {
			return opts, errArgType
		}
		opts.Password = passwd.String()
	}
	rawCellValue := arg.Get("raw_cell_value")
	if rawCellValue.Type() != js.TypeUndefined {
		if rawCellValue.Type() != js.TypeBoolean {
			return opts, errArgType
		}
		opts.RawCellValue = rawCellValue.Bool()
	}
	return opts, nil
}

// prepareArgs provides a method to check the excelize wrapper function
// arguments by given rules.
func prepareArgs(args []js.Value, types []argsRule) error {
	rules, arguments, opts := len(types), len(args), false
	if rules > 0 && types[rules-1].opts {
		opts = true
	}
	if (!opts && arguments != rules) || (opts && (arguments != rules && arguments+1 != rules)) {
		return errArgNum
	}
	for i := 0; i < len(types); i++ {
		if opts && i == arguments {
			return nil
		}
		excepted, received := types[i], args[i]
		if inTypeSlice(excepted.types, received.Type()) == -1 {
			return errArgType
		}
	}
	return nil
}

// ColumnNumberToName provides a function to convert the integer to Excel sheet
// column title.
func CellNameToCoordinates(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": 0, "row": 0, "error": nil}
	if err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	col, row, err := excelize.CellNameToCoordinates(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], ret["row"] = col, row
	return js.ValueOf(ret)
}

// ColumnNameToNumber provides a function to convert Excel sheet column name
// (case-insensitive) to int. The function returns an error if column name
// incorrect.
func ColumnNameToNumber(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": 0, "error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], err = excelize.ColumnNameToNumber(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// ColumnNumberToName provides a function to convert the integer to Excel sheet
// column title.
func ColumnNumberToName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": 0, "error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeNumber}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], err = excelize.ColumnNumberToName(args[0].Int())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// CoordinatesToCellName converts [X, Y] coordinates to alpha-numeric cell name
// or returns an error.
func CoordinatesToCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"cell": "", "error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeBoolean}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var abs bool
	if len(args) == 3 {
		abs = args[2].Bool()
	}
	ret["cell"], err = excelize.CoordinatesToCellName(args[0].Int(), args[1].Int(), abs)
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// HSLToRGB converts an HSL triple to a RGB triple.
func HSLToRGB(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"r": 0, "g": 0, "b": 0, "error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["r"], ret["g"], ret["b"] = excelize.HSLToRGB(args[0].Float(), args[1].Float(), args[2].Float())
	return js.ValueOf(ret)
}

// JoinCellName joins cell name from column name and row number.
func JoinCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"cell": "", "error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["cell"], err = excelize.JoinCellName(args[0].String(), args[1].Int())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// RGBToHSL converts an RGB triple to a HSL triple.
func RGBToHSL(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"h": 0, "s": 0, "l": 0, "error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["h"], ret["s"], ret["l"] = excelize.RGBToHSL(uint8(args[0].Int()), uint8(args[1].Int()), uint8(args[2].Int()))
	return js.ValueOf(ret)
}

// SplitCellName splits cell name to column name and row number.
func SplitCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": "", "row": 0, "error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], ret["row"], err = excelize.SplitCellName(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// ThemeColor applied the color with tint value.
func ThemeColor(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"color": "", "error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["color"] = excelize.ThemeColor(args[0].String(), args[1].Float())
	return js.ValueOf(ret)
}

// NewFile provides a function to create new file by default template.
func NewFile(this js.Value, args []js.Value) interface{} {
	fn := map[string]interface{}{"error": nil}
	fn["error"] = nil
	if err := prepareArgs(args, []argsRule{}); err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	return regInteropFunc(excelize.NewFile(), fn)
}

// OpenReader read data stream from buffer and return a populated spreadsheet
// file.
func OpenReader(this js.Value, args []js.Value) interface{} {
	fn := map[string]interface{}{"error": nil}
	fn["error"] = nil
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeObject}},
		{types: []js.Type{js.TypeObject}, opts: true},
	})
	if err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	if args[0].Length() == 0 {
		fn["error"] = excelize.ErrParameterInvalid.Error()
		return js.ValueOf(fn)
	}
	buf := make([]byte, args[0].Get("length").Int())
	js.CopyBytesToGo(buf, args[0])
	var opts excelize.Options
	if len(args) == 2 {
		if opts, err = prepareOptions(args[1]); err != nil {
			fn["error"] = err.Error()
			return js.ValueOf(fn)
		}
	}
	f, err := excelize.OpenReader(bytes.NewReader(buf), opts)
	if err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	return regInteropFunc(f, fn)
}

// AddChart provides the method to add chart in a sheet by given chart format
// set (such as offset, scale, aspect ratio setting and print settings) and
// properties set.
func AddChart(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if len(args) == 4 {
			err = f.AddChart(args[0].String(), args[1].String(), args[2].String(), args[3].String())
		} else {
			err = f.AddChart(args[0].String(), args[1].String(), args[2].String())
		}
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddChartSheet provides the method to create a chartsheet by given chart
// format set (such as offset, scale, aspect ratio setting and print settings)
// and properties set. In Excel a chartsheet is a worksheet that only contains
// a chart.
func AddChartSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if len(args) == 3 {
			err = f.AddChartSheet(args[0].String(), args[1].String(), args[2].String())
		} else {
			err = f.AddChartSheet(args[0].String(), args[1].String())
		}
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddComment provides the method to add comment in a sheet by given
// worksheet index, cell and format set (such as author and text). Note that
// the max author length is 255 and the max text length is 32512.
// @param sheet The worksheet name
func AddComment(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.AddComment(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddPictureFromBytes provides the method to add picture in a sheet by given
// picture format set (such as offset, scale, aspect ratio setting and print
// settings), file base name, extension name and file bytes.
func AddPictureFromBytes(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		buf := make([]byte, args[5].Get("length").Int())
		js.CopyBytesToGo(buf, args[5])
		if err := f.AddPictureFromBytes(args[0].String(), args[1].String(), args[2].String(), args[3].String(), args[4].String(), buf); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddPivotTable provides the method to add pivot table by given pivot table
// options. Note that the same fields can not in Columns, Rows and Filter
// fields at the same time.
func AddPivotTable(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opt excelize.PivotTableOption
		if err := json.Unmarshal([]byte(args[0].String()), &opt); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.AddPivotTable(&opt); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddShape provides the method to add shape in a sheet by given worksheet
// index, shape format set (such as offset, scale, aspect ratio setting and
// print settings) and properties set.
func AddShape(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.AddShape(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddTable provides the method to add table in a worksheet by given worksheet
// name, range reference and format set.
func AddTable(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.AddTable(args[0].String(), args[1].String(), args[2].String(), args[3].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AutoFilter provides the method to add auto filter in a worksheet by given
// worksheet name, range reference and settings. An auto filter in Excel is a
// way of filtering a 2D range of data based on some simple criteria.
func AutoFilter(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.AutoFilter(args[0].String(), args[1].String(), args[2].String(), args[3].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// CalcCellValue provides a function to get calculated cell value. This feature
// is currently in working processing. Iterative calculation, implicit
// intersection, explicit intersection, array formula, table formula and some
// other formulas are not supported currently.
func CalcCellValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"value": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["value"], err = f.CalcCellValue(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// CopySheet provides a function to duplicate a worksheet by gave source and
// target worksheet index. Note that currently doesn't support duplicate
// workbooks that contain tables, charts or pictures.
func CopySheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.CopySheet(args[0].Int(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteChart provides a function to delete chart in spreadsheet by given
// worksheet name and cell reference.
func DeleteChart(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeleteChart(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteComment provides the method to delete comment in a sheet by given
// worksheet name.
func DeleteComment(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeleteComment(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteDataValidation delete data validation by given worksheet name and
// reference sequence. All data validations in the worksheet will be deleted
// if not specify reference sequence parameter.
func DeleteDataValidation(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if len(args) == 2 {
			err = f.DeleteDataValidation(args[0].String(), args[1].String())
		} else {
			err = f.DeleteDataValidation(args[0].String())
		}
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeletePicture provides a function to delete charts in spreadsheet by given
// worksheet name and cell reference. Note that the image file won't be
// deleted from the document currently.
func DeletePicture(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeletePicture(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteSheet provides a function to delete worksheet in a workbook by given
// worksheet name. Use this method with caution, which will affect changes in
// references such as formulas, charts, and so on. If there is any referenced
// value of the deleted worksheet, it will cause a file error when you open
// it. This function will be invalid when only one worksheet is left.
func DeleteSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		f.DeleteSheet(args[0].String())
		return js.ValueOf(ret)
	}
}

// DuplicateRow inserts a copy of specified row (by its Excel row number)
// below. Use this method with caution, which will affect changes in
// references such as formulas, charts, and so on. If there is any referenced
// value of the worksheet, it will cause a file error when you open it. The
// excelize only partially updates these references currently.
func DuplicateRow(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DuplicateRow(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DuplicateRowTo inserts a copy of specified row by it Excel number to
// specified row position moving down exists rows after target position. Use
// this method with caution, which will affect changes in references such as
// formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func DuplicateRowTo(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DuplicateRowTo(args[0].String(), args[1].Int(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetActiveSheetIndex provides a function to get active sheet index of the
// spreadsheet. If not found the active sheet will be return integer 0.
func GetActiveSheetIndex(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"index": 0, "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["index"] = f.GetActiveSheetIndex()
		return js.ValueOf(ret)
	}
}

// GetAppProps provides a function to get document application properties.
func GetAppProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{
			"application":        "",
			"scale_crop":         false,
			"doc_security":       0,
			"company":            "",
			"links_up_to_date":   false,
			"hyperlinks_changed": false,
			"app_version":        "",
			"error":              nil,
		}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props, err := f.GetAppProps()
		if err != nil {
			ret["error"] = err.Error()
		}
		s := reflect.ValueOf(props).Elem()
		for i := 0; i < s.NumField(); i++ {
			ret[s.Type().Field(i).Tag.Get("json")] = s.Field(i).Interface()
		}
		return js.ValueOf(ret)
	}
}

// GetCellFormula provides a function to get formula from cell by given
// worksheet name and cell reference in spreadsheet.
func GetCellFormula(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"formula": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["formula"], err = f.GetCellFormula(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCellHyperLink gets a cell hyperlink based on the given worksheet name and
// cell reference. If the cell has a hyperlink, it will return 'true' and the
// link address, otherwise it will return 'false' and an empty link address.
func GetCellHyperLink(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"ok": false, "location": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["ok"], ret["location"], err = f.GetCellHyperLink(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCellStyle provides a function to get cell style index by given
// worksheet name and cell reference.
func GetCellStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["style"], err = f.GetCellStyle(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCellValue provides a function to get formatted value from cell by given
// worksheet name and cell reference in spreadsheet. The return value is
// converted to the `string` data type. If the cell format can be applied to
// the value of a cell, the applied value will be returned, otherwise the
// original value will be returned. All cells' values will be the same in a
// merged range.
func GetCellValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"value": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["value"], err = f.GetCellValue(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// GetColOutlineLevel provides a function to get outline level of a single
// column by given worksheet name and column name.
func GetColOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"level": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["level"], err = f.GetColOutlineLevel(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetColStyle provides a function to get column style ID by given worksheet
// name and column name.
func GetColStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["style"], err = f.GetColStyle(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetColVisible provides a function to get visible of a single column by given
// worksheet name and column name.
func GetColVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"visible": false, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["visible"], err = f.GetColVisible(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetColWidth provides a function to get column width by given worksheet name
// and column name.
func GetColWidth(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"width": 9.140625, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["width"], err = f.GetColWidth(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCols gets the value of all cells by columns on the worksheet based on the
// given worksheet name, returned as a two-dimensional array, where the value
// of the cell is converted to the `string` type. If the cell format can be
// applied to the value of the cell, the applied value will be used, otherwise
// the original value will be used.
func GetCols(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"result": js.ValueOf([]interface{}{}), "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 2 {
			if opts, err = prepareOptions(args[1]); err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
		}
		matrix, err := f.GetCols(args[0].String(), opts)
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		result := make([]interface{}, len(matrix))
		for c, col := range matrix {
			line := make([]interface{}, len(col))
			for r, cell := range col {
				line[r] = cell
			}
			result[c] = js.ValueOf(line)
		}
		ret["result"] = result
		return js.ValueOf(ret)
	}
}

// GetRowHeight provides a function to get row height by given worksheet name
// and row number.
func GetRowHeight(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"height": 15, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["height"], err = f.GetRowHeight(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetRowOutlineLevel provides a function to get outline level number of a
// single row by given worksheet name and Excel row number.
func GetRowOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"level": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["level"], err = f.GetRowOutlineLevel(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetRowVisible provides a function to get visible of a single row by given
// worksheet name and Excel row number.
func GetRowVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"visible": false, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["visible"], err = f.GetRowVisible(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetRows return all the rows in a sheet by given worksheet name, returned as
// a two-dimensional array, where the value of the cell is converted to the
// string type. If the cell format can be applied to the value of the cell,
// the applied value will be used, otherwise the original value will be used.
// GetRows fetched the rows with value or formula cells, the continually blank
// cells in the tail of each row will be skipped, so the length of each row
// may be inconsistent.
func GetRows(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"result": js.ValueOf([]interface{}{}), "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 2 {
			if opts, err = prepareOptions(args[1]); err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
		}
		matrix, err := f.GetRows(args[0].String(), opts)
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		result := make([]interface{}, len(matrix))
		for r, row := range matrix {
			line := make([]interface{}, len(row))
			for c, cell := range row {
				line[c] = cell
			}
			result[r] = js.ValueOf(line)
		}
		ret["result"] = result
		return js.ValueOf(ret)
	}
}

// GetSheetIndex provides a function to get a sheet index of the workbook by
// the given sheet name. If the given sheet name is invalid or sheet doesn't
// exist, it will return an integer type value -1.
func GetSheetIndex(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"index": 0, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["index"] = f.GetSheetIndex(args[0].String())
		return js.ValueOf(ret)
	}
}

// GetSheetList provides a function to get worksheets, chart sheets, and dialog
// sheets name list of the workbook.
func GetSheetList(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"list": js.ValueOf([]interface{}{}), "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		sheetList := f.GetSheetList()
		expected := make([]interface{}, len(sheetList))
		for i, name := range sheetList {
			expected[i] = name
		}
		ret["list"] = expected
		return js.ValueOf(ret)
	}
}

// GetSheetMap provides a function to get worksheets, chart sheets, dialog
// sheets ID and name map of the workbook.
func GetSheetMap(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"sheets": js.ValueOf(map[string]interface{}{}), "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		sheetMap := f.GetSheetMap()
		result := make(map[string]interface{}, len(sheetMap))
		for i, name := range sheetMap {
			result[strconv.Itoa(i)] = name
		}
		ret["sheets"] = result
		return js.ValueOf(ret)
	}
}

// GetSheetName provides a function to get the sheet name of the workbook by
// the given sheet index. If the given sheet index is invalid, it will return
// an empty string.
func GetSheetName(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"name": "", "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["name"] = f.GetSheetName(args[0].Int())
		return js.ValueOf(ret)
	}
}

// GetSheetVisible provides a function to get worksheet visible by given
// worksheet name.
func GetSheetVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"visible": false, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["visible"] = f.GetSheetVisible(args[0].String())
		return js.ValueOf(ret)
	}
}

// GroupSheets provides a function to group worksheets by given worksheets
// name. Group worksheets must contain an active worksheet.
func GroupSheets(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		length := args[0].Length()
		var slice []string
		for i := 0; i < length; i++ {
			arg := args[0].Index(i)
			switch arg.Type() {
			case js.TypeString:
				slice = append(slice, arg.String())
			default:
			}
		}
		if err := f.GroupSheets(slice); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// InsertCols provides a function to insert new columns before the given column
// name and number of columns.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func InsertCols(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.InsertCols(args[0].String(), args[1].String(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// InsertPageBreak create a page break to determine where the printed page ends
// and where begins the next one by given worksheet name and cell, so the
// content before the page break will be printed on one page and after the
// page break on another.
func InsertPageBreak(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.InsertPageBreak(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// InsertRows provides a function to insert new rows after the given Excel
// row number starting from 1 and number of rows.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func InsertRows(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.InsertRows(args[0].String(), args[1].Int(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// MergeCell provides a function to merge cells by given range reference and
// sheet name. Merging cells only keeps the upper-left cell value, and
// discards the other values.
//
// If you create a merged cell that overlaps with another existing merged
// cell, those merged cells that already exist will be removed. The cell
// references tuple after merging in the following range will be: A1
// (x3,y1) D1(x2,y1) A8(x3,y4) D8(x2,y4)
//
//	             B1(x1,y1)      D1(x2,y1)
//	           +------------------------+
//	           |                        |
//	 A4(x3,y3) |    C4(x4,y3)           |
//	+------------------------+          |
//	|          |             |          |
//	|          |B5(x1,y2)    | D5(x2,y2)|
//	|          +------------------------+
//	|                        |
//	|A8(x3,y4)      C8(x4,y4)|
//	+------------------------+
func MergeCell(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.MergeCell(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// NewConditionalStyle provides a function to create style for conditional
// format by given style format. The parameters are the same with the
// NewStyle function. Note that the color field uses RGB color code and only
// support to set font, fills, alignment and borders currently.
func NewConditionalStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["style"], err = f.NewConditionalStyle(args[0].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// NewSheet provides the function to create a new sheet by given a worksheet
// name and returns the index of the sheets in the workbook after it appended.
// Note that when creating a new workbook, the default worksheet named
// `Sheet1` will be created.
func NewSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"index": 0, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["index"] = f.NewSheet(args[0].String())
		return js.ValueOf(ret)
	}
}

// NewStyle provides a function to create the style for cells by given JSON.
// Note that the color field uses RGB color code.
func NewStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["style"], err = f.NewStyle(args[0].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// RemoveCol provides a function to remove single column by given worksheet
// name and column index.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func RemoveCol(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.RemoveCol(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// RemovePageBreak remove a page break by given worksheet name and cell
// reference.
func RemovePageBreak(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.RemovePageBreak(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// RemoveRow provides a function to remove single row by given worksheet name
// and Excel row number.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func RemoveRow(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.RemoveRow(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SearchSheet provides a function to get cell reference by given worksheet
// name, cell value, and regular expression. The function doesn't support
// searching on the calculated result, formatted numbers and conditional
// lookup currently. If it is a merged cell, it will return the cell reference
// of the upper left cell of the merged range reference.
func SearchSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"result": js.ValueOf([]interface{}{}), "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}, opts: true},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var reg bool
		if len(args) == 3 {
			reg = args[2].Bool()
		}
		result, err := f.SearchSheet(args[0].String(), args[1].String(), reg)
		if err != nil {
			ret["error"] = err.Error()
		}
		excepted := make([]interface{}, len(result))
		for i, cell := range result {
			excepted[i] = cell
		}
		ret["result"] = excepted
		return js.ValueOf(ret)
	}
}

// SetActiveSheet provides a function to set the default active sheet of the
// workbook by a given index. Note that the active index is different from the
// ID returned by function GetSheetMap(). It should be greater than or equal
// to 0 and less than the total worksheet numbers.
func SetActiveSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		f.SetActiveSheet(args[0].Int())
		return js.ValueOf(ret)
	}
}

// SetCellBool provides a function to set bool type value of a cell by given
// worksheet name, cell reference and cell value.
func SetCellBool(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellBool(args[0].String(), args[1].String(), args[2].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellDefault provides a function to set string type value of a cell as
// default format without escaping the cell.
func SetCellDefault(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellDefault(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellFloat sets a floating point value into a cell. The precision
// parameter specifies how many places after the decimal will be shown
// while -1 is a special value that will use as many decimal places as
// necessary to represent the number. bitSize is 32 or 64 depending on if a
// float32 or float64 was originally used for the value.
func SetCellFloat(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellFloat(args[0].String(), args[1].String(), args[2].Float(), args[3].Int(), args[4].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellInt provides a function to set int type value of a cell by given
// worksheet name, cell reference and cell value.
func SetCellInt(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellInt(args[0].String(), args[1].String(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellStr provides a function to set string type value of a cell. Total
// number of characters that a cell can contain 32767 characters.
func SetCellStr(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellStr(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellStyle provides a function to add style attribute for cells by given
// worksheet name, range reference and style ID. Note that diagonalDown and
// diagonalUp type border should be use same color in the same range.
// SetCellStyle will overwrite the existing styles for the cell, it won't
// append or merge style with existing styles.
func SetCellStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellStyle(args[0].String(), args[1].String(), args[2].String(), args[3].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellValue provides a function to set the value of a cell. The specified
// coordinates should not be in the first row of the table, a complex number
// can be set with string text.
//
// You can set numbers format by the SetCellStyle function. If you need to set
// the specialized date in Excel like January 0, 1900 or February 29, 1900.
// Please set the cell value as number 0 or 60, then create and bind the
// date-time number format style for the cell.
func SetCellValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean, js.TypeNumber, js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var value interface{}
		switch args[2].Type() {
		case js.TypeBoolean:
			value = args[2].Bool()
		case js.TypeNumber:
			value = args[2].Float()
		case js.TypeString:
			value = args[2].String()
		default:
		}
		if err := f.SetCellValue(args[0].String(), args[1].String(), value); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColOutlineLevel provides a function to set outline level of a single
// column by given worksheet name and column name. The value of parameter
// 'level' is 1-7.
func SetColOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColOutlineLevel(args[0].String(), args[1].String(), uint8(args[2].Int())); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColStyle provides a function to set style of columns by given worksheet
// name, columns range and style ID. Note that this will overwrite the
// existing styles for the columns, it won't append or merge style with
// existing styles.
func SetColStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColStyle(args[0].String(), args[1].String(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColVisible provides a function to set visible columns by given worksheet
// name, columns range and visibility.
func SetColVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColVisible(args[0].String(), args[1].String(), args[2].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColWidth provides a function to set the width of a single column or
// multiple columns.
func SetColWidth(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColWidth(args[0].String(), args[1].String(), args[2].String(), args[3].Float()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetConditionalFormat provides a function to create conditional formatting
// rule for cell value. Conditional formatting is a feature of Excel which
// allows you to apply a format to a cell or a range of cells based on certain
// criteria.
func SetConditionalFormat(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetConditionalFormat(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetDefaultFont changes the default font in the workbook.
func SetDefaultFont(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		f.SetDefaultFont(args[0].String())
		return js.ValueOf(ret)
	}
}

// SetPanes provides a function to create and remove freeze panes and split
// panes by given worksheet name and panes format set.
func SetPanes(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetPanes(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowHeight provides a function to set the height of a single row.
func SetRowHeight(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowHeight(args[0].String(), args[1].Int(), args[2].Float()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowOutlineLevel provides a function to set outline level number of a
// single row by given worksheet name and Excel row number. The value of
// parameter 'level' is 1-7.
func SetRowOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowOutlineLevel(args[0].String(), args[1].Int(), uint8(args[2].Int())); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowStyle provides a function to set the style of rows by given worksheet
// name, row range, and style ID. Note that this will overwrite the existing
// styles for the rows, it won't append or merge style with existing styles.
func SetRowStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowStyle(args[0].String(), args[1].Int(), args[2].Int(), args[3].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowStyle provides a function to set the style of rows by given worksheet
// name, row range, and style ID. Note that this will overwrite the existing
// styles for the rows, it won't append or merge style with existing styles.
func SetRowVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowVisible(args[0].String(), args[1].Int(), args[2].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetCol writes an array to column by given worksheet name, starting cell
// reference and a pointer to array type 'slice'.
func SetSheetCol(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		length := args[2].Length()
		slice := make([]interface{}, length)
		for i := 0; i < length; i++ {
			arg := args[2].Index(i)
			switch arg.Type() {
			case js.TypeBoolean:
				slice[i] = arg.Bool()
			case js.TypeNumber:
				slice[i] = arg.Float()
			case js.TypeString:
				slice[i] = arg.String()
			default:
			}
		}
		if err := f.SetSheetCol(args[0].String(), args[1].String(), &slice); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetName provides a function to set the worksheet name by given source
// and target worksheet names. Maximum 31 characters are allowed in sheet
// title and this function only changes the name of the sheet and will not
// update the sheet name in the formula or reference associated with the cell.
// So there may be problem formula error or reference missing.
func SetSheetName(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		f.SetSheetName(args[0].String(), args[1].String())
		return js.ValueOf(ret)
	}
}

// SetSheetRow writes an array to row by given worksheet name, starting cell
// reference and a pointer to array type 'slice'.
func SetSheetRow(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		length := args[2].Length()
		var slice []interface{}
		for i := 0; i < length; i++ {
			arg := args[2].Index(i)
			switch arg.Type() {
			case js.TypeBoolean:
				slice = append(slice, arg.Bool())
			case js.TypeNumber:
				slice = append(slice, arg.Float())
			case js.TypeString:
				slice = append(slice, arg.String())
			default:
				slice = append(slice, nil)
			}
		}
		if err := f.SetSheetRow(args[0].String(), args[1].String(), &slice); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetVisible provides a function to set worksheet visible by given
// worksheet name. A workbook must contain at least one visible worksheet. If
// the given worksheet has been activated, this setting will be invalidated.
func SetSheetVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetSheetVisible(args[0].String(), args[1].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UngroupSheets provides a function to ungroup worksheets.
func UngroupSheets(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.UngroupSheets(); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UnmergeCell provides a function to unmerge a given range reference.
func UnmergeCell(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.UnmergeCell(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UnprotectSheet provides a function to remove protection for a sheet,
// specified the second optional password parameter to remove sheet protection
// with password verification.
func UnprotectSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if len(args) == 2 {
			err = f.UnprotectSheet(args[0].String(), args[1].String())
		} else {
			err = f.UnprotectSheet(args[0].String())
		}
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UnsetConditionalFormat provides a function to unset the conditional format
// by given worksheet name and range reference.
func UnsetConditionalFormat(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.UnsetConditionalFormat(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UpdateLinkedValue fix linked values within a spreadsheet are not updating in
// Office Excel application. This function will be remove value tag when met a
// cell have a linked value.
func UpdateLinkedValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		f.UpdateLinkedValue()
		return js.ValueOf(ret)
	}
}

// WriteToBuffer provides a function to get the contents buffer from the saved
// file, and it allocates space in memory. Be careful when the file size is
// large.
func WriteToBuffer(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 1 {
			if opts, err = prepareOptions(args[0]); err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
		}
		buf := new(bytes.Buffer)
		if err := f.Write(buf, opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		src := buf.Bytes()
		dst := js.Global().Get("Uint8Array").New(len(src))
		js.CopyBytesToJS(dst, src)
		return dst
	}
}
