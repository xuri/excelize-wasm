// Copyright 2022 - 2023 The excelize-wasm Authors. All rights reserved. Use of
// this source code is governed by a BSD-style license that can be found in
// the LICENSE file.
//
// Package excelize providing a set of functions that allow you to write to and
// read from XLAM / XLSM / XLSX / XLTM / XLTX files. Supports reading and
// writing spreadsheet documents generated by Microsoft Excelâ„¢ 2007 and later.
// Supports complex components by high compatibility, and provided streaming
// API for generating or reading data from a worksheet with huge amounts of
// data. This library needs Go version 1.16 or later.

package main

import (
	"bytes"
	"errors"
	"reflect"
	"strconv"
	"syscall/js"

	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"

	_ "golang.org/x/image/tiff"

	"github.com/xuri/excelize/v2"
)

// argsRule represents the rule of the excelize wrapper function argument.
type argsRule struct {
	opts  bool
	types []js.Type
}

var (
	// goBaseTypes defines Go's basic data types.
	goBaseTypes = map[reflect.Kind]bool{
		reflect.Bool:    true,
		reflect.Int:     true,
		reflect.Int8:    true,
		reflect.Int16:   true,
		reflect.Int32:   true,
		reflect.Int64:   true,
		reflect.Uint:    true,
		reflect.Uint8:   true,
		reflect.Uint16:  true,
		reflect.Uint32:  true,
		reflect.Uint64:  true,
		reflect.Uintptr: true,
		reflect.Float32: true,
		reflect.Float64: true,
		reflect.Map:     true,
		reflect.String:  true,
	}
	// jsToBaseGoTypeFuncs defined functions mapping for JavaScript to Go basic
	// data types convention.
	jsToBaseGoTypeFuncs = map[reflect.Kind]func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error){
		reflect.Bool: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeBoolean {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(jsVal.Bool()), nil
		},
		reflect.Uint: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeNumber {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(uint(jsVal.Float())), nil
		},
		reflect.Uint8: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeNumber {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(uint8(jsVal.Float())), nil
		},
		reflect.Uint64: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeNumber {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(uint64(jsVal.Float())), nil
		},
		reflect.Int: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeNumber {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(int(jsVal.Float())), nil
		},
		reflect.Int64: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeNumber {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(int64(jsVal.Float())), nil
		},
		reflect.Float64: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeNumber {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(jsVal.Float()), nil
		},
		reflect.String: func(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
			if jsVal.Type() != js.TypeString {
				return reflect.ValueOf(nil), errArgType
			}
			return reflect.ValueOf(jsVal.String()), nil
		},
	}
	// goBaseValueToJSFuncs defined functions mapping for Go basic data types
	// value to JavaScript convention.
	goBaseValueToJSFuncs = map[reflect.Kind]func(goVal reflect.Value, kind reflect.Kind) (interface{}, error){
		reflect.Bool: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return goVal.Bool(), nil
		},
		reflect.Uint: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return int(goVal.Uint()), nil
		},
		reflect.Uint8: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return uint8(goVal.Uint()), nil
		},
		reflect.Uint64: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return int(goVal.Uint()), nil
		},
		reflect.Int: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return int(goVal.Int()), nil
		},
		reflect.Int64: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return goVal.Int(), nil
		},
		reflect.Float64: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return goVal.Float(), nil
		},
		reflect.String: func(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
			if kind != goVal.Kind() {
				return nil, errArgType
			}
			return goVal.String(), nil
		},
	}
	errArgNum  = errors.New("invalid arguments in call")
	errArgType = errors.New("invalid argument data type")
)

func main() {
	c := make(chan struct{})
	regFuncs()
	<-c
}

// regFuncs register all exported JavaScript functions on the Window ot Global.
func regFuncs() {
	for name, impl := range map[string]func(this js.Value, args []js.Value) interface{}{
		"CellNameToCoordinates": CellNameToCoordinates,
		"ColumnNameToNumber":    ColumnNameToNumber,
		"ColumnNumberToName":    ColumnNumberToName,
		"CoordinatesToCellName": CoordinatesToCellName,
		"HSLToRGB":              HSLToRGB,
		"JoinCellName":          JoinCellName,
		"RGBToHSL":              RGBToHSL,
		"SplitCellName":         SplitCellName,
		"ThemeColor":            ThemeColor,
		"NewFile":               NewFile,
		"OpenReader":            OpenReader,
	} {
		js.Global().Get("excelize").Set(name, js.FuncOf(impl))
	}
	regConstants()
}

// regConstants register all exported JavaScript functions on the Window ot Global.
func regConstants() {
	for name, constant := range map[string]int{
		"CultureNameUnknown": int(excelize.CultureNameUnknown),
		"CultureNameEnUS":    int(excelize.CultureNameEnUS),
		"CultureNameZhCN":    int(excelize.CultureNameZhCN),
	} {
		js.Global().Get("excelize").Set(name, constant)
	}
	for name, constant := range map[string]int{
		"FormControlNote":         int(excelize.FormControlNote),
		"FormControlButton":       int(excelize.FormControlButton),
		"FormControlOptionButton": int(excelize.FormControlOptionButton),
		"FormControlSpinButton":   int(excelize.FormControlSpinButton),
		"FormControlCheckBox":     int(excelize.FormControlCheckBox),
		"FormControlGroupBox":     int(excelize.FormControlGroupBox),
		"FormControlLabel":        int(excelize.FormControlLabel),
		"FormControlScrollBar":    int(excelize.FormControlScrollBar),
	} {
		js.Global().Get("excelize").Set(name, constant)
	}
	for name, constant := range map[string]int{
		"Area":                        int(excelize.Area),
		"AreaStacked":                 int(excelize.AreaStacked),
		"AreaPercentStacked":          int(excelize.AreaPercentStacked),
		"Area3D":                      int(excelize.Area3D),
		"Area3DStacked":               int(excelize.Area3DStacked),
		"Area3DPercentStacked":        int(excelize.Area3DPercentStacked),
		"Bar":                         int(excelize.Bar),
		"BarStacked":                  int(excelize.BarStacked),
		"BarPercentStacked":           int(excelize.BarPercentStacked),
		"Bar3DClustered":              int(excelize.Bar3DClustered),
		"Bar3DStacked":                int(excelize.Bar3DStacked),
		"Bar3DPercentStacked":         int(excelize.Bar3DPercentStacked),
		"Bar3DConeClustered":          int(excelize.Bar3DConeClustered),
		"Bar3DConeStacked":            int(excelize.Bar3DConeStacked),
		"Bar3DConePercentStacked":     int(excelize.Bar3DConePercentStacked),
		"Bar3DPyramidClustered":       int(excelize.Bar3DPyramidClustered),
		"Bar3DPyramidStacked":         int(excelize.Bar3DPyramidStacked),
		"Bar3DPyramidPercentStacked":  int(excelize.Bar3DPyramidPercentStacked),
		"Bar3DCylinderClustered":      int(excelize.Bar3DCylinderClustered),
		"Bar3DCylinderStacked":        int(excelize.Bar3DCylinderStacked),
		"Bar3DCylinderPercentStacked": int(excelize.Bar3DCylinderPercentStacked),
		"Col":                         int(excelize.Col),
		"ColStacked":                  int(excelize.ColStacked),
		"ColPercentStacked":           int(excelize.ColPercentStacked),
		"Col3D":                       int(excelize.Col3D),
		"Col3DClustered":              int(excelize.Col3DClustered),
		"Col3DStacked":                int(excelize.Col3DStacked),
		"Col3DPercentStacked":         int(excelize.Col3DPercentStacked),
		"Col3DCone":                   int(excelize.Col3DCone),
		"Col3DConeClustered":          int(excelize.Col3DConeClustered),
		"Col3DConeStacked":            int(excelize.Col3DConeStacked),
		"Col3DConePercentStacked":     int(excelize.Col3DConePercentStacked),
		"Col3DPyramid":                int(excelize.Col3DPyramid),
		"Col3DPyramidClustered":       int(excelize.Col3DPyramidClustered),
		"Col3DPyramidStacked":         int(excelize.Col3DPyramidStacked),
		"Col3DPyramidPercentStacked":  int(excelize.Col3DPyramidPercentStacked),
		"Col3DCylinder":               int(excelize.Col3DCylinder),
		"Col3DCylinderClustered":      int(excelize.Col3DCylinderClustered),
		"Col3DCylinderStacked":        int(excelize.Col3DCylinderStacked),
		"Col3DCylinderPercentStacked": int(excelize.Col3DCylinderPercentStacked),
		"Doughnut":                    int(excelize.Doughnut),
		"Line":                        int(excelize.Line),
		"Line3D":                      int(excelize.Line3D),
		"Pie":                         int(excelize.Pie),
		"Pie3D":                       int(excelize.Pie3D),
		"PieOfPie":                    int(excelize.PieOfPie),
		"BarOfPie":                    int(excelize.BarOfPie),
		"Radar":                       int(excelize.Radar),
		"Scatter":                     int(excelize.Scatter),
		"Surface3D":                   int(excelize.Surface3D),
		"WireframeSurface3D":          int(excelize.WireframeSurface3D),
		"Contour":                     int(excelize.Contour),
		"WireframeContour":            int(excelize.WireframeContour),
		"Bubble":                      int(excelize.Bubble),
		"Bubble3D":                    int(excelize.Bubble3D),
	} {
		js.Global().Get("excelize").Set(name, constant)
	}
	for name, constant := range map[string]int{
		"ChartLineSolid":     int(excelize.ChartLineSolid),
		"ChartLineNone":      int(excelize.ChartLineNone),
		"ChartLineAutomatic": int(excelize.ChartLineAutomatic),
	} {
		js.Global().Get("excelize").Set(name, constant)
	}
}

// regInteropFunc register all exported JavaScript functions.
func regInteropFunc(f *excelize.File, fn map[string]interface{}) interface{} {
	for name, impl := range map[string]func(this js.Value, args []js.Value) interface{}{
		"AddChart":                    AddChart(f),
		"AddChartSheet":               AddChartSheet(f),
		"AddComment":                  AddComment(f),
		"AddDataValidation":           AddDataValidation(f),
		"AddFormControl":              AddFormControl(f),
		"AddPictureFromBytes":         AddPictureFromBytes(f),
		"AddPivotTable":               AddPivotTable(f),
		"AddShape":                    AddShape(f),
		"AddSlicer":                   AddSlicer(f),
		"AddSparkline":                AddSparkline(f),
		"AddTable":                    AddTable(f),
		"AutoFilter":                  AutoFilter(f),
		"CalcCellValue":               CalcCellValue(f),
		"CopySheet":                   CopySheet(f),
		"DeleteChart":                 DeleteChart(f),
		"DeleteComment":               DeleteComment(f),
		"DeleteDataValidation":        DeleteDataValidation(f),
		"DeleteDefinedName":           DeleteDefinedName(f),
		"DeleteFormControl":           DeleteFormControl(f),
		"DeletePicture":               DeletePicture(f),
		"DeleteSheet":                 DeleteSheet(f),
		"DeleteTable":                 DeleteTable(f),
		"DuplicateRow":                DuplicateRow(f),
		"DuplicateRowTo":              DuplicateRowTo(f),
		"GetActiveSheetIndex":         GetActiveSheetIndex(f),
		"GetAppProps":                 GetAppProps(f),
		"GetCellFormula":              GetCellFormula(f),
		"GetCellHyperLink":            GetCellHyperLink(f),
		"GetCellRichText":             GetCellRichText(f),
		"GetCellStyle":                GetCellStyle(f),
		"GetCellValue":                GetCellValue(f),
		"GetColOutlineLevel":          GetColOutlineLevel(f),
		"GetCols":                     GetCols(f),
		"GetColStyle":                 GetColStyle(f),
		"GetColVisible":               GetColVisible(f),
		"GetColWidth":                 GetColWidth(f),
		"GetComments":                 GetComments(f),
		"GetConditionalStyle":         GetConditionalStyle(f),
		"GetDefaultFont":              GetDefaultFont(f),
		"GetDefinedName":              GetDefinedName(f),
		"GetDocProps":                 GetDocProps(f),
		"GetFormControls":             GetFormControls(f),
		"GetPageLayout":               GetPageLayout(f),
		"GetPageMargins":              GetPageMargins(f),
		"GetPanes":                    GetPanes(f),
		"GetPictures":                 GetPictures(f),
		"GetPictureCells":             GetPictureCells(f),
		"GetPivotTables":              GetPivotTables(f),
		"GetRowHeight":                GetRowHeight(f),
		"GetRowOutlineLevel":          GetRowOutlineLevel(f),
		"GetRows":                     GetRows(f),
		"GetRowVisible":               GetRowVisible(f),
		"GetSheetIndex":               GetSheetIndex(f),
		"GetSheetList":                GetSheetList(f),
		"GetSheetMap":                 GetSheetMap(f),
		"GetSheetName":                GetSheetName(f),
		"GetSheetProps":               GetSheetProps(f),
		"GetSheetView":                GetSheetView(f),
		"GetSheetVisible":             GetSheetVisible(f),
		"GetStyle":                    GetStyle(f),
		"GetTables":                   GetTables(f),
		"GetWorkbookProps":            GetWorkbookProps(f),
		"GroupSheets":                 GroupSheets(f),
		"InsertCols":                  InsertCols(f),
		"InsertPageBreak":             InsertPageBreak(f),
		"InsertRows":                  InsertRows(f),
		"MergeCell":                   MergeCell(f),
		"NewConditionalStyle":         NewConditionalStyle(f),
		"NewSheet":                    NewSheet(f),
		"NewStyle":                    NewStyle(f),
		"ProtectSheet":                ProtectSheet(f),
		"ProtectWorkbook":             ProtectWorkbook(f),
		"RemoveCol":                   RemoveCol(f),
		"RemovePageBreak":             RemovePageBreak(f),
		"RemoveRow":                   RemoveRow(f),
		"SearchSheet":                 SearchSheet(f),
		"SetActiveSheet":              SetActiveSheet(f),
		"SetAppProps":                 SetAppProps(f),
		"SetCellBool":                 SetCellBool(f),
		"SetCellDefault":              SetCellDefault(f),
		"SetCellFloat":                SetCellFloat(f),
		"SetCellFormula":              SetCellFormula(f),
		"SetCellHyperLink":            SetCellHyperLink(f),
		"SetCellInt":                  SetCellInt(f),
		"SetCellRichText":             SetCellRichText(f),
		"SetCellStr":                  SetCellStr(f),
		"SetCellStyle":                SetCellStyle(f),
		"SetCellUint":                 SetCellInt(f),
		"SetCellValue":                SetCellValue(f),
		"SetColOutlineLevel":          SetColOutlineLevel(f),
		"SetColStyle":                 SetColStyle(f),
		"SetColVisible":               SetColVisible(f),
		"SetColWidth":                 SetColWidth(f),
		"SetConditionalFormat":        SetConditionalFormat(f),
		"SetDefaultFont":              SetDefaultFont(f),
		"SetDefinedName":              SetDefinedName(f),
		"SetDocProps":                 SetDocProps(f),
		"SetHeaderFooter":             SetHeaderFooter(f),
		"SetPageLayout":               SetPageLayout(f),
		"SetPageMargins":              SetPageMargins(f),
		"SetPanes":                    SetPanes(f),
		"SetRowHeight":                SetRowHeight(f),
		"SetRowOutlineLevel":          SetRowOutlineLevel(f),
		"SetRowStyle":                 SetRowStyle(f),
		"SetRowVisible":               SetRowVisible(f),
		"SetSheetBackgroundFromBytes": SetSheetBackgroundFromBytes(f),
		"SetSheetCol":                 SetSheetCol(f),
		"SetSheetName":                SetSheetName(f),
		"SetSheetProps":               SetSheetProps(f),
		"SetSheetRow":                 SetSheetRow(f),
		"SetSheetView":                SetSheetView(f),
		"SetSheetVisible":             SetSheetVisible(f),
		"SetWorkbookProps":            SetWorkbookProps(f),
		"UngroupSheets":               UngroupSheets(f),
		"UnmergeCell":                 UnmergeCell(f),
		"UnprotectSheet":              UnprotectSheet(f),
		"UnprotectWorkbook":           UnprotectWorkbook(f),
		"UnsetConditionalFormat":      UnsetConditionalFormat(f),
		"UpdateLinkedValue":           UpdateLinkedValue(f),
		"WriteToBuffer":               WriteToBuffer(f),
	} {
		fn[name] = js.FuncOf(impl)
	}
	return js.ValueOf(fn)
}

// inTypeSlice provides a method to check if an element is present in an
// JavaScript type value array, and return the index of its location,
// otherwise return -1.
func inTypeSlice(a []js.Type, x js.Type) int {
	for idx, n := range a {
		if x == n {
			return idx
		}
	}
	return -1
}

// jsToGoBaseType convert JavaScript value to Go basic data type variable.
func jsToGoBaseType(jsVal js.Value, kind reflect.Kind) (reflect.Value, error) {
	fn, ok := jsToBaseGoTypeFuncs[kind]
	if !ok {
		return reflect.ValueOf(nil), errArgType
	}
	return fn(jsVal, kind)
}

// jsValueToGo convert JavaScript object to Go variable base on the given Go
// structure types, this function extract each fields of the structure from
// object recursively.
func jsValueToGo(jsVal js.Value, goType reflect.Type) (reflect.Value, error) {
	result := reflect.New(goType)
	s := result.Elem()

	for resultFieldIdx := 0; resultFieldIdx < s.NumField(); resultFieldIdx++ {
		field := goType.Field(resultFieldIdx)
		if goBaseTypes[field.Type.Kind()] {
			jsBaseVal := jsVal.Get(field.Name)
			if jsBaseVal.Type() != js.TypeUndefined {
				goBaseVal, err := jsToGoBaseType(jsBaseVal, field.Type.Kind())
				if err != nil {
					return result, err
				}
				s.Field(resultFieldIdx).Set(goBaseVal.Convert(s.Field(resultFieldIdx).Type()))
			}
			continue
		}
		switch field.Type.Kind() {
		case reflect.Ptr:
			// Pointer of the Go data type, for example: *excelize.Options or *string
			ptrType := field.Type.Elem()
			if !goBaseTypes[ptrType.Kind()] {
				// Pointer of the Go struct, for example: *excelize.Options
				jsObjVal := jsVal.Get(field.Name)
				if jsObjVal.Type() != js.TypeUndefined {
					if jsObjVal.Type() != js.TypeObject {
						return result, errArgType
					}
					v, err := jsValueToGo(jsObjVal, ptrType)
					if err != nil {
						return result, err
					}
					s.Field(resultFieldIdx).Set(v)
				}
			}
			if goBaseTypes[ptrType.Kind()] {
				// Pointer of the Go basic data type, for example: *string
				jsBaseVal := jsVal.Get(field.Name)
				if jsBaseVal.Type() != js.TypeUndefined {
					v, err := jsToGoBaseType(jsBaseVal, ptrType.Kind())
					if err != nil {
						return result, err
					}
					x := reflect.New(ptrType)
					x.Elem().Set(v)
					s.Field(resultFieldIdx).Set(x.Elem().Addr())
				}
			}
		case reflect.Struct:
			// The Go struct, for example: excelize.Options, convert sub fields recursively
			structType := field.Type
			jsObjVal := jsVal.Get(field.Name)
			if jsObjVal.Type() != js.TypeUndefined {
				if jsObjVal.Type() != js.TypeObject {
					return result, errArgType
				}
				v, err := jsValueToGo(jsObjVal, structType)
				if err != nil {
					return result, err
				}
				s.Field(resultFieldIdx).Set(v.Elem())
			}
		case reflect.Slice:
			// The Go data type array, for example:
			// []*excelize.Options, []excelize.Options, []string, []*string
			ele := field.Type.Elem()
			jsArray := jsVal.Get(field.Name)
			if jsArray.Type() != js.TypeUndefined {
				if jsArray.Type() != js.TypeObject {
					return result, errArgType
				}
				if ele.Kind() == reflect.Ptr {
					// Pointer array of the Go data type, for example: []*excelize.Options or []*string
					subEle := ele.Elem()
					for i := 0; i < jsArray.Length(); i++ {
						if goBaseTypes[subEle.Kind()] {
							// Pointer array of the Go basic data type, for example: []*string
							v, err := jsToGoBaseType(jsArray.Index(i), subEle.Kind())
							if err != nil {
								return result, err
							}
							x := reflect.New(subEle)
							x.Elem().Set(v)
							s.Field(resultFieldIdx).Set(reflect.Append(s.Field(resultFieldIdx), x.Elem().Addr()))
						} else {
							// Pointer array of the Go struct, for example: []*excelize.Options
							v, err := jsValueToGo(jsArray.Index(i), subEle)
							if err != nil {
								return result, err
							}
							x := reflect.New(subEle)
							x.Elem().Set(v.Elem())
							s.Field(resultFieldIdx).Set(reflect.Append(s.Field(resultFieldIdx), x.Elem().Addr()))
						}
					}
				} else {
					// The Go data type array, for example: []excelize.Options or []string
					subEle := ele
					for i := 0; i < jsArray.Length(); i++ {
						if subEle.Kind() == reflect.Uint8 { // []byte
							buf := make([]byte, jsArray.Length())
							js.CopyBytesToGo(buf, jsArray)
							s.Field(resultFieldIdx).Set(reflect.ValueOf(buf))
							break
						}
						if goBaseTypes[subEle.Kind()] {
							// The Go basic data type array, for example: []string
							v, err := jsToGoBaseType(jsArray.Index(i), subEle.Kind())
							if err != nil {
								return result, err
							}
							s.Field(resultFieldIdx).Set(reflect.Append(s.Field(resultFieldIdx), v))
						} else {
							// The Go struct array, for example: []excelize.Options
							v, err := jsValueToGo(jsArray.Index(i), subEle)
							if err != nil {
								return result, err
							}
							s.Field(resultFieldIdx).Set(reflect.Append(s.Field(resultFieldIdx), v.Elem()))
						}
					}
				}
			}
		}
	}
	return result, nil
}

// goBaseTypeToJS convert Go basic data type value to JavaScript variable.
func goBaseTypeToJS(goVal reflect.Value, kind reflect.Kind) (interface{}, error) {
	fn, ok := goBaseValueToJSFuncs[kind]
	if !ok {
		return nil, errArgType
	}
	return fn(goVal, kind)
}

// goValueToJS convert Go variable to JavaScript object base on the given Go
// structure types, this function extract each fields of the structure from
// structure variable recursively.
func goValueToJS(goVal reflect.Value, goType reflect.Type) (map[string]interface{}, error) {
	result := map[string]interface{}{}
	s := reflect.New(goType).Elem()
	for i := 0; i < s.NumField(); i++ {
		field := s.Type().Field(i)
		if goBaseTypes[s.Field(i).Kind()] {
			v, err := goBaseTypeToJS(goVal.Field(i), s.Field(i).Kind())
			if err != nil {
				return nil, err
			}
			result[field.Name] = v
			continue
		}
		switch s.Field(i).Kind() {
		case reflect.Ptr:
			// Pointer of the Go data type, for example: *excelize.Options or *string
			ptrType := field.Type.Elem()
			if !goBaseTypes[ptrType.Kind()] {
				// Pointer of the Go struct, for example: *excelize.Options
				goStructVal := goVal.Field(i)
				if !goStructVal.IsNil() {
					v, err := goValueToJS(goStructVal.Elem(), ptrType)
					if err != nil {
						return nil, err
					}
					result[field.Name] = v
				}
			}
			if goBaseTypes[ptrType.Kind()] {
				// Pointer of the Go basic data type, for example: *string
				goBaseVal := goVal.Field(i)
				if !goBaseVal.IsNil() {
					v, err := goBaseTypeToJS(goBaseVal.Elem(), ptrType.Kind())
					if err != nil {
						return nil, err
					}
					result[field.Name] = v
				}
			}
		case reflect.Struct:
			// The Go struct, for example: excelize.Options, convert sub fields recursively
			structType := field.Type
			goStructVal := goVal.Field(i)
			if !goStructVal.IsZero() {
				v, err := goValueToJS(goStructVal, structType)
				if err != nil {
					return nil, err
				}
				result[field.Name] = v
			}
		case reflect.Slice:
			// The Go data type array, for example:
			// []*excelize.Options, []excelize.Options, []string, []*string
			ele := field.Type.Elem()
			goSlice := goVal.Field(i)
			for s := 0; s < goSlice.Len(); s++ {
				if ele.Kind() == reflect.Ptr {
					// Pointer array of the Go data type, for example: []*excelize.Options or []*string
					subEle := ele.Elem()
					if !goBaseTypes[subEle.Kind()] {
						// Pointer of the Go struct, for example: *excelize.Options
						goStructVal := goSlice.Index(s)
						if !goStructVal.IsNil() {
							v, err := goValueToJS(goStructVal.Elem(), subEle)
							if err != nil {
								return nil, err
							}
							if _, ok := result[field.Name]; !ok {
								result[field.Name] = []interface{}{}
							}
							x := result[field.Name].([]interface{})
							x = append(x, v)
							result[field.Name] = x
						}
					}
					if goBaseTypes[subEle.Kind()] {
						// Pointer of the Go basic data type, for example: *string
						goBaseVal := goSlice.Index(s)
						if !goBaseVal.IsNil() {
							v, err := goBaseTypeToJS(goBaseVal.Elem(), subEle.Kind())
							if err != nil {
								return nil, err
							}
							if _, ok := result[field.Name]; !ok {
								result[field.Name] = []interface{}{}
							}
							x := result[field.Name].([]interface{})
							x = append(x, v)
							result[field.Name] = x
						}
					}
				} else {
					// The Go data type array, for example: []excelize.Options or []string
					subEle := ele
					if !goBaseTypes[subEle.Kind()] {
						// Value of the Go struct, for example: excelize.Options
						goStructVal := goSlice.Index(s)
						if !goStructVal.IsZero() {
							v, err := goValueToJS(goStructVal, subEle)
							if err != nil {
								return nil, err
							}
							if _, ok := result[field.Name]; !ok {
								result[field.Name] = []interface{}{}
							}
							x := result[field.Name].([]interface{})
							x = append(x, v)
							result[field.Name] = x
						}
					}
					if goBaseTypes[subEle.Kind()] {
						// Value of the Go basic data type, for example: string
						goBaseVal := goSlice.Index(s)
						if !goBaseVal.IsZero() {
							if subEle.Kind() == reflect.Uint8 { // []byte
								dst := js.Global().Get("Uint8Array").New(goSlice.Len())
								js.CopyBytesToJS(dst, goSlice.Bytes())
								result[field.Name] = dst
								break
							}
							v, err := goBaseTypeToJS(goBaseVal, subEle.Kind())
							if err != nil {
								return nil, err
							}
							if _, ok := result[field.Name]; !ok {
								result[field.Name] = []interface{}{}
							}
							x := result[field.Name].([]interface{})
							x = append(x, v)
							result[field.Name] = x
						}
					}
				}
			}
		}
	}
	return result, nil
}

// prepareArgs provides a method to check the excelize wrapper function
// arguments by given rules.
func prepareArgs(args []js.Value, types []argsRule) error {
	rules, arguments, opts := len(types), len(args), false
	if rules > 0 && types[rules-1].opts {
		opts = true
	}
	if (!opts && arguments != rules) || (opts && (arguments != rules && arguments+1 != rules)) {
		return errArgNum
	}
	for i := 0; i < len(types); i++ {
		if opts && i == arguments {
			return nil
		}
		excepted, received := types[i], args[i]
		if inTypeSlice(excepted.types, received.Type()) == -1 {
			return errArgType
		}
	}
	return nil
}

// CellNameToCoordinates converts alphanumeric cell name to [X, Y] coordinates
// or returns an error.
func CellNameToCoordinates(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": 0, "row": 0, "error": nil}
	if err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	col, row, err := excelize.CellNameToCoordinates(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], ret["row"] = col, row
	return js.ValueOf(ret)
}

// ColumnNameToNumber provides a function to convert Excel sheet column name
// (case-insensitive) to int. The function returns an error if column name
// incorrect.
func ColumnNameToNumber(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": 0, "error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], err = excelize.ColumnNameToNumber(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// ColumnNumberToName provides a function to convert the integer to Excel sheet
// column title.
func ColumnNumberToName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": 0, "error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeNumber}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], err = excelize.ColumnNumberToName(args[0].Int())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// CoordinatesToCellName converts [X, Y] coordinates to alpha-numeric cell name
// or returns an error.
func CoordinatesToCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"cell": "", "error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeBoolean}, opts: true},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	var abs bool
	if len(args) == 3 {
		abs = args[2].Bool()
	}
	ret["cell"], err = excelize.CoordinatesToCellName(args[0].Int(), args[1].Int(), abs)
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// HSLToRGB converts an HSL triple to a RGB triple.
func HSLToRGB(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"r": 0, "g": 0, "b": 0, "error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["r"], ret["g"], ret["b"] = excelize.HSLToRGB(args[0].Float(), args[1].Float(), args[2].Float())
	return js.ValueOf(ret)
}

// JoinCellName joins cell name from column name and row number.
func JoinCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"cell": "", "error": nil}
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["cell"], err = excelize.JoinCellName(args[0].String(), args[1].Int())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// RGBToHSL converts an RGB triple to a HSL triple.
func RGBToHSL(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"h": 0, "s": 0, "l": 0, "error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["h"], ret["s"], ret["l"] = excelize.RGBToHSL(uint8(args[0].Int()), uint8(args[1].Int()), uint8(args[2].Int()))
	return js.ValueOf(ret)
}

// SplitCellName splits cell name to column name and row number.
func SplitCellName(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"col": "", "row": 0, "error": nil}
	err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}})
	if err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["col"], ret["row"], err = excelize.SplitCellName(args[0].String())
	if err != nil {
		ret["error"] = err.Error()
	}
	return js.ValueOf(ret)
}

// ThemeColor applied the color with tint value.
func ThemeColor(this js.Value, args []js.Value) interface{} {
	ret := map[string]interface{}{"color": "", "error": nil}
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeString}},
		{types: []js.Type{js.TypeNumber}},
	}); err != nil {
		ret["error"] = err.Error()
		return js.ValueOf(ret)
	}
	ret["color"] = excelize.ThemeColor(args[0].String(), args[1].Float())
	return js.ValueOf(ret)
}

// NewFile provides a function to create new file by default template.
func NewFile(this js.Value, args []js.Value) interface{} {
	fn := map[string]interface{}{"error": nil}
	fn["error"] = nil
	if err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeObject}, opts: true},
	}); err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	if len(args) == 1 {
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.Options{}))
		if err != nil {
			fn["error"] = err.Error()
			return js.ValueOf(fn)
		}
		return regInteropFunc(excelize.NewFile(goVal.Elem().Interface().(excelize.Options)), fn)
	}
	return regInteropFunc(excelize.NewFile(), fn)
}

// OpenReader read data stream from buffer and return a populated spreadsheet
// file.
func OpenReader(this js.Value, args []js.Value) interface{} {
	fn := map[string]interface{}{"error": nil}
	fn["error"] = nil
	err := prepareArgs(args, []argsRule{
		{types: []js.Type{js.TypeObject}},
		{types: []js.Type{js.TypeObject}, opts: true},
	})
	if err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	if args[0].Length() == 0 {
		fn["error"] = excelize.ErrParameterInvalid.Error()
		return js.ValueOf(fn)
	}
	buf := make([]byte, args[0].Get("length").Int())
	js.CopyBytesToGo(buf, args[0])
	var opts excelize.Options
	if len(args) == 2 {
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Options{}))
		if err != nil {
			fn["error"] = err.Error()
			return js.ValueOf(fn)
		}
		opts = goVal.Elem().Interface().(excelize.Options)
	}
	f, err := excelize.OpenReader(bytes.NewReader(buf), opts)
	if err != nil {
		fn["error"] = err.Error()
		return js.ValueOf(fn)
	}
	return regInteropFunc(f, fn)
}

// AddChart provides the method to add chart in a sheet by given chart format
// set (such as offset, scale, aspect ratio setting and print settings) and
// properties set.
func AddChart(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var chart, combo excelize.Chart
		chartVal, err := jsValueToGo(args[2], reflect.TypeOf(excelize.Chart{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if args[2].Get("Type").IsUndefined() {
			ret["error"] = errArgType.Error()
			return js.ValueOf(ret)
		}
		chart = chartVal.Elem().Interface().(excelize.Chart)
		if len(args) == 4 {
			comboVal, err := jsValueToGo(args[3], reflect.TypeOf(excelize.Chart{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			if args[3].Get("Type").IsUndefined() {
				ret["error"] = errArgType.Error()
				return js.ValueOf(ret)
			}
			combo = comboVal.Elem().Interface().(excelize.Chart)
			if err = f.AddChart(args[0].String(), args[1].String(), &chart, &combo); err != nil {
				ret["error"] = err.Error()
			}
			return js.ValueOf(ret)
		}
		if err = f.AddChart(args[0].String(), args[1].String(), &chart); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddChartSheet provides the method to create a chartsheet by given chart
// format set (such as offset, scale, aspect ratio setting and print settings)
// and properties set. In Excel a chartsheet is a worksheet that only contains
// a chart.
func AddChartSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var chart, combo excelize.Chart
		chartVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Chart{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		chart = chartVal.Elem().Interface().(excelize.Chart)
		if len(args) == 3 {
			comboVal, err := jsValueToGo(args[2], reflect.TypeOf(excelize.Chart{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			combo = comboVal.Elem().Interface().(excelize.Chart)
			if err = f.AddChartSheet(args[0].String(), &chart, &combo); err != nil {
				ret["error"] = err.Error()
			}
			return js.ValueOf(ret)
		}
		if err = f.AddChartSheet(args[0].String(), &chart); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddComment provides the method to add comment in a sheet by given
// worksheet index, cell and format set (such as author and text). Note that
// the max author length is 255 and the max text length is 32512.
func AddComment(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opt excelize.Comment
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Comment{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opt = goVal.Elem().Interface().(excelize.Comment)
		if err := f.AddComment(args[0].String(), opt); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddDataValidation provides set data validation on a range of the worksheet
// by given data validation object and worksheet name.
func AddDataValidation(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var dv excelize.DataValidation
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.DataValidation{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		dv = goVal.Elem().Interface().(excelize.DataValidation)
		if err := f.AddDataValidation(args[0].String(), &dv); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddFormControl provides the method to add form control button in a worksheet
// by given worksheet name and form control options. Supported form control
// type: button, check box, group box, label, option button, scroll bar and
// spinner. If set macro for the form control, the workbook extension should be
// XLSM or XLTM. Scroll value must be between 0 and 30000.
func AddFormControl(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.FormControl
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.FormControl{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.FormControl)
		if err := f.AddFormControl(args[0].String(), opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddPictureFromBytes provides the method to add picture in a sheet by given
// picture format set (such as offset, scale, aspect ratio setting and print
// settings), file base name, extension name and file bytes.
func AddPictureFromBytes(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var pic excelize.Picture
		goVal, err := jsValueToGo(args[2], reflect.TypeOf(excelize.Picture{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		pic = goVal.Elem().Interface().(excelize.Picture)
		if err := f.AddPictureFromBytes(args[0].String(), args[1].String(), &pic); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddPivotTable provides the method to add pivot table by given pivot table
// options. Note that the same fields can not in Columns, Rows and Filter
// fields at the same time.
func AddPivotTable(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.PivotTableOptions
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.PivotTableOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.PivotTableOptions)
		if err := f.AddPivotTable(&opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddShape provides the method to add shape in a sheet by given worksheet
// index, shape format set (such as offset, scale, aspect ratio setting and
// print settings) and properties set.
func AddShape(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Shape
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Shape{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.Shape)
		if err := f.AddShape(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddSlicer function inserts a slicer by giving the worksheet name and slicer
// settings.
func AddSlicer(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.SlicerOptions
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.SlicerOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.SlicerOptions)
		if err := f.AddSlicer(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddSparkline provides a function to add sparklines to the worksheet by
// given formatting options. Sparklines are small charts that fit in a single
// cell and are used to show trends in data. Sparklines are a feature of Excel
// 2010 and later only. You can write them to an XLSX file that can be read by
// Excel 2007, but they won't be displayed.
func AddSparkline(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.SparklineOptions
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.SparklineOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.SparklineOptions)
		if err := f.AddSparkline(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AddTable provides the method to add table in a worksheet by given worksheet
// name, range reference and format set.
func AddTable(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Table
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Table{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.Table)
		if err := f.AddTable(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// AutoFilter provides the method to add auto filter in a worksheet by given
// worksheet name, range reference and settings. An auto filter in Excel is a
// way of filtering a 2D range of data based on some simple criteria.
func AutoFilter(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts []excelize.AutoFilterOptions
		for i := 0; i < args[2].Length(); i++ {
			goVal, err := jsValueToGo(args[2].Index(i), reflect.TypeOf(excelize.AutoFilterOptions{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = append(opts, goVal.Elem().Interface().(excelize.AutoFilterOptions))
		}
		if err := f.AutoFilter(args[0].String(), args[1].String(), opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// CalcCellValue provides a function to get calculated cell value. This feature
// is currently in working processing. Iterative calculation, implicit
// intersection, explicit intersection, array formula, table formula and some
// other formulas are not supported currently.
func CalcCellValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"value": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 3 {
			goVal, err := jsValueToGo(args[2], reflect.TypeOf(excelize.Options{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = goVal.Elem().Interface().(excelize.Options)
		}
		if ret["value"], err = f.CalcCellValue(args[0].String(), args[1].String(), opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// CopySheet provides a function to duplicate a worksheet by gave source and
// target worksheet index. Note that currently doesn't support duplicate
// workbooks that contain tables, charts or pictures.
func CopySheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.CopySheet(args[0].Int(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteChart provides a function to delete chart in spreadsheet by given
// worksheet name and cell reference.
func DeleteChart(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeleteChart(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteComment provides the method to delete comment in a sheet by given
// worksheet name.
func DeleteComment(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeleteComment(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteDataValidation delete data validation by given worksheet name and
// reference sequence. All data validations in the worksheet will be deleted
// if not specify reference sequence parameter.
func DeleteDataValidation(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if len(args) == 2 {
			err = f.DeleteDataValidation(args[0].String(), args[1].String())
		} else {
			err = f.DeleteDataValidation(args[0].String())
		}
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteDefinedName provides a function to delete the defined names of the
// workbook or worksheet. If not specified scope, the default scope is
// workbook.
func DeleteDefinedName(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var definedName excelize.DefinedName
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.DefinedName{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		definedName = goVal.Elem().Interface().(excelize.DefinedName)
		if err = f.DeleteDefinedName(&definedName); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// DeleteFormControl provides the method to delete form control in a worksheet
// by given worksheet name and cell reference.
func DeleteFormControl(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeleteFormControl(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeletePicture provides a function to delete charts in spreadsheet by given
// worksheet name and cell reference. Note that the image file won't be
// deleted from the document currently.
func DeletePicture(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeletePicture(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteSheet provides a function to delete worksheet in a workbook by given
// worksheet name. Use this method with caution, which will affect changes in
// references such as formulas, charts, and so on. If there is any referenced
// value of the deleted worksheet, it will cause a file error when you open
// it. This function will be invalid when only one worksheet is left.
func DeleteSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeleteSheet(args[0].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DeleteTable provides the method to delete table by given table name.
func DeleteTable(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DeleteTable(args[0].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DuplicateRow inserts a copy of specified row (by its Excel row number)
// below. Use this method with caution, which will affect changes in
// references such as formulas, charts, and so on. If there is any referenced
// value of the worksheet, it will cause a file error when you open it. The
// excelize only partially updates these references currently.
func DuplicateRow(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DuplicateRow(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// DuplicateRowTo inserts a copy of specified row by it Excel number to
// specified row position moving down exists rows after target position. Use
// this method with caution, which will affect changes in references such as
// formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func DuplicateRowTo(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.DuplicateRowTo(args[0].String(), args[1].Int(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetActiveSheetIndex provides a function to get active sheet index of the
// spreadsheet. If not found the active sheet will be return integer 0.
func GetActiveSheetIndex(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"index": 0, "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["index"] = f.GetActiveSheetIndex()
		return js.ValueOf(ret)
	}
}

// GetAppProps provides a function to get document application properties.
func GetAppProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		p := map[string]interface{}{
			"Application":       "",
			"ScaleCrop":         false,
			"DocSecurity":       0,
			"Company":           "",
			"LinksUpToDate":     false,
			"HyperlinksChanged": false,
			"AppVersion":        "",
		}
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props, err := f.GetAppProps()
		if err != nil {
			ret["error"] = err.Error()
		}
		s := reflect.ValueOf(props).Elem()
		for i := 0; i < s.NumField(); i++ {
			p[s.Type().Field(i).Name] = s.Field(i).Interface()
		}
		ret["props"] = p
		return js.ValueOf(ret)
	}
}

// GetCellFormula provides a function to get formula from cell by given
// worksheet name and cell reference in spreadsheet.
func GetCellFormula(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"formula": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["formula"], err = f.GetCellFormula(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCellHyperLink gets a cell hyperlink based on the given worksheet name and
// cell reference. If the cell has a hyperlink, it will return 'true' and the
// link address, otherwise it will return 'false' and an empty link address.
func GetCellHyperLink(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"ok": false, "location": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["ok"], ret["location"], err = f.GetCellHyperLink(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCellRichText provides a function to get rich text of cell by given
// worksheet.
func GetCellRichText(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		runs, err := f.GetCellRichText(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
		}
		ret["runs"] = []interface{}{}
		for i := 0; i < len(runs); i++ {
			if jsVal, err := goValueToJS(reflect.ValueOf(runs[i]),
				reflect.TypeOf(excelize.RichTextRun{})); err == nil {
				x := ret["runs"].([]interface{})
				x = append(x, jsVal)
				ret["runs"] = x
			}
		}
		return js.ValueOf(ret)
	}
}

// GetCellStyle provides a function to get cell style index by given
// worksheet name and cell reference.
func GetCellStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["style"], err = f.GetCellStyle(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCellValue provides a function to get formatted value from cell by given
// worksheet name and cell reference in spreadsheet. The return value is
// converted to the `string` data type. If the cell format can be applied to
// the value of a cell, the applied value will be returned, otherwise the
// original value will be returned. All cells' values will be the same in a
// merged range.
func GetCellValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"value": "", "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 3 {
			goVal, err := jsValueToGo(args[2], reflect.TypeOf(excelize.Options{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = goVal.Elem().Interface().(excelize.Options)
		}
		if ret["value"], err = f.GetCellValue(args[0].String(), args[1].String(), opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// GetColOutlineLevel provides a function to get outline level of a single
// column by given worksheet name and column name.
func GetColOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"level": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["level"], err = f.GetColOutlineLevel(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetColStyle provides a function to get column style ID by given worksheet
// name and column name.
func GetColStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["style"], err = f.GetColStyle(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetColVisible provides a function to get visible of a single column by given
// worksheet name and column name.
func GetColVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"visible": false, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["visible"], err = f.GetColVisible(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetColWidth provides a function to get column width by given worksheet name
// and column name.
func GetColWidth(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"width": 9.140625, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["width"], err = f.GetColWidth(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetCols gets the value of all cells by columns on the worksheet based on the
// given worksheet name, returned as a two-dimensional array, where the value
// of the cell is converted to the `string` type. If the cell format can be
// applied to the value of the cell, the applied value will be used, otherwise
// the original value will be used.
func GetCols(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"result": js.ValueOf([]interface{}{}), "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 2 {
			goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Options{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = goVal.Elem().Interface().(excelize.Options)
		}
		matrix, err := f.GetCols(args[0].String(), opts)
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		result := make([]interface{}, len(matrix))
		for c, col := range matrix {
			line := make([]interface{}, len(col))
			for r, cell := range col {
				line[r] = cell
			}
			result[c] = js.ValueOf(line)
		}
		ret["result"] = result
		return js.ValueOf(ret)
	}
}

// GetComments retrieves all comments in a worksheet by given worksheet name.
func GetComments(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"comments": []interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		cmts, err := f.GetComments(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		for _, cmt := range cmts {
			if jsVal, err := goValueToJS(reflect.ValueOf(cmt),
				reflect.TypeOf(excelize.Comment{})); err == nil {
				x := ret["comments"].([]interface{})
				x = append(x, jsVal)
				ret["comments"] = x
			}
		}
		return js.ValueOf(ret)
	}
}

// GetConditionalStyle returns conditional format style definition by specified
// style index.
func GetConditionalStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		style, err := f.GetConditionalStyle(args[0].Int())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(*style),
			reflect.TypeOf(excelize.Style{})); err == nil {
			ret["style"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetDefaultFont provides the default font name currently set in the
// workbook. The spreadsheet generated by excelize default font is Calibri.
func GetDefaultFont(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"fontName": "", "error": nil}
		err := prepareArgs(args, []argsRule{})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["fontName"], err = f.GetDefaultFont(); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetDefinedName provides a function to get the defined names of the workbook
// or worksheet.
func GetDefinedName(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"definedNames": []interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		for _, dn := range f.GetDefinedName() {
			if jsVal, err := goValueToJS(reflect.ValueOf(dn),
				reflect.TypeOf(excelize.DefinedName{})); err == nil {
				x := ret["definedNames"].([]interface{})
				x = append(x, jsVal)
				ret["definedNames"] = x
			}
		}
		return js.ValueOf(ret)
	}
}

// GetDocProps provides a function to get document core properties.
func GetDocProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"props": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props, err := f.GetDocProps()
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(*props),
			reflect.TypeOf(excelize.DocProperties{})); err == nil {
			ret["props"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetFormControls retrieves all form controls in a worksheet by a given
// worksheet name. Note that, this function does not support getting the width
// and height of the form controls currently.
func GetFormControls(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"formControls": []interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		formControls, err := f.GetFormControls(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		for _, formCtrl := range formControls {
			if jsVal, err := goValueToJS(reflect.ValueOf(formCtrl),
				reflect.TypeOf(excelize.FormControl{})); err == nil {
				x := ret["formControls"].([]interface{})
				x = append(x, jsVal)
				ret["formControls"] = x
			}
		}
		return js.ValueOf(ret)
	}
}

// GetPageLayout provides a function to gets worksheet page layout.
func GetPageLayout(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"opts": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts, err := f.GetPageLayout(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(opts),
			reflect.TypeOf(excelize.PageLayoutOptions{})); err == nil {
			ret["opts"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetPageMargins provides a function to get worksheet page margins.
func GetPageMargins(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"opts": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts, err := f.GetPageMargins(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(opts),
			reflect.TypeOf(excelize.PageLayoutMarginsOptions{})); err == nil {
			ret["opts"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetPanes provides a function to get freeze panes, split panes, and worksheet
// views by given worksheet name.
func GetPanes(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"panes": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts, err := f.GetPanes(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(opts),
			reflect.TypeOf(excelize.Panes{})); err == nil {
			ret["panes"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetPictures provides a function to get picture meta info and raw content
// embed in spreadsheet by given worksheet and cell name. This function
// returns the image contents as []byte data types.
func GetPictures(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"pictures": []interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		pics, err := f.GetPictures(args[0].String(), args[1].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		for _, pic := range pics {
			if jsVal, err := goValueToJS(reflect.ValueOf(pic),
				reflect.TypeOf(excelize.Picture{})); err == nil {
				x := ret["pictures"].([]interface{})
				x = append(x, jsVal)
				ret["pictures"] = x
			}
		}
		return js.ValueOf(ret)
	}
}

// GetPictureCells returns all picture cell references in a worksheet by a
// specific worksheet name.
func GetPictureCells(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"cells": js.ValueOf([]interface{}{}), "error": nil}
		if err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		cells, err := f.GetPictureCells(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		expected := make([]interface{}, len(cells))
		for i, name := range cells {
			expected[i] = name
		}
		ret["cells"] = expected
		return js.ValueOf(ret)
	}
}

// GetPivotTables returns all pivot table definitions in a worksheet by given
// worksheet name.
func GetPivotTables(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"opts": []interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts, err := f.GetPivotTables(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		for _, opt := range opts {
			if jsVal, err := goValueToJS(reflect.ValueOf(opt),
				reflect.TypeOf(excelize.PivotTableOptions{})); err == nil {
				x := ret["opts"].([]interface{})
				x = append(x, jsVal)
				ret["opts"] = x
			}
		}
		return js.ValueOf(ret)
	}
}

// GetRowHeight provides a function to get row height by given worksheet name
// and row number.
func GetRowHeight(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"height": 15, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["height"], err = f.GetRowHeight(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetRowOutlineLevel provides a function to get outline level number of a
// single row by given worksheet name and Excel row number.
func GetRowOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"level": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["level"], err = f.GetRowOutlineLevel(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetRowVisible provides a function to get visible of a single row by given
// worksheet name and Excel row number.
func GetRowVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"visible": false, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["visible"], err = f.GetRowVisible(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetRows return all the rows in a sheet by given worksheet name, returned as
// a two-dimensional array, where the value of the cell is converted to the
// string type. If the cell format can be applied to the value of the cell,
// the applied value will be used, otherwise the original value will be used.
// GetRows fetched the rows with value or formula cells, the continually blank
// cells in the tail of each row will be skipped, so the length of each row
// may be inconsistent.
func GetRows(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"result": js.ValueOf([]interface{}{}), "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 2 {
			goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Options{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = goVal.Elem().Interface().(excelize.Options)
		}
		matrix, err := f.GetRows(args[0].String(), opts)
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		result := make([]interface{}, len(matrix))
		for r, row := range matrix {
			line := make([]interface{}, len(row))
			for c, cell := range row {
				line[c] = cell
			}
			result[r] = js.ValueOf(line)
		}
		ret["result"] = result
		return js.ValueOf(ret)
	}
}

// GetSheetIndex provides a function to get a sheet index of the workbook by
// the given sheet name. If the given sheet name is invalid or sheet doesn't
// exist, it will return an integer type value -1.
func GetSheetIndex(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"index": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["index"], err = f.GetSheetIndex(args[0].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetSheetList provides a function to get worksheets, chart sheets, and dialog
// sheets name list of the workbook.
func GetSheetList(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"list": js.ValueOf([]interface{}{}), "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		sheetList := f.GetSheetList()
		expected := make([]interface{}, len(sheetList))
		for i, name := range sheetList {
			expected[i] = name
		}
		ret["list"] = expected
		return js.ValueOf(ret)
	}
}

// GetSheetMap provides a function to get worksheets, chart sheets, dialog
// sheets ID and name map of the workbook.
func GetSheetMap(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"sheets": js.ValueOf(map[string]interface{}{}), "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		sheetMap := f.GetSheetMap()
		result := make(map[string]interface{}, len(sheetMap))
		for i, name := range sheetMap {
			result[strconv.Itoa(i)] = name
		}
		ret["sheets"] = result
		return js.ValueOf(ret)
	}
}

// GetSheetName provides a function to get the sheet name of the workbook by
// the given sheet index. If the given sheet index is invalid, it will return
// an empty string.
func GetSheetName(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"name": "", "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		ret["name"] = f.GetSheetName(args[0].Int())
		return js.ValueOf(ret)
	}
}

// GetSheetProps provides a function to get worksheet properties.
func GetSheetProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"props": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props, err := f.GetSheetProps(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(props),
			reflect.TypeOf(excelize.SheetPropsOptions{})); err == nil {
			ret["props"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetSheetView gets the value of sheet view options. The viewIndex may be
// negative and if so is counted backward (-1 is the last view).
func GetSheetView(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"opts": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts, err := f.GetSheetView(args[0].String(), args[1].Int())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(opts),
			reflect.TypeOf(excelize.ViewOptions{})); err == nil {
			ret["opts"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetSheetVisible provides a function to get worksheet visible by given
// worksheet name.
func GetSheetVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"visible": false, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["visible"], err = f.GetSheetVisible(args[0].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// GetStyle provides a function to get style definition by given style index.
func GetStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		style, err := f.GetStyle(args[0].Int())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(*style),
			reflect.TypeOf(excelize.Style{})); err == nil {
			ret["style"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GetTables provides the method to get all tables in a worksheet by given
// worksheet name.
func GetTables(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"tables": []interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		tables, err := f.GetTables(args[0].String())
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		for _, tbl := range tables {
			if jsVal, err := goValueToJS(reflect.ValueOf(tbl),
				reflect.TypeOf(excelize.Table{})); err == nil {
				x := ret["tables"].([]interface{})
				x = append(x, jsVal)
				ret["tables"] = x
			}
		}
		return js.ValueOf(ret)
	}
}

// GetWorkbookProps provides a function to gets workbook properties.
func GetWorkbookProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"props": map[string]interface{}{}, "error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props, err := f.GetWorkbookProps()
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if jsVal, err := goValueToJS(reflect.ValueOf(props),
			reflect.TypeOf(excelize.WorkbookPropsOptions{})); err == nil {
			ret["props"] = jsVal
		}
		return js.ValueOf(ret)
	}
}

// GroupSheets provides a function to group worksheets by given worksheets
// name. Group worksheets must contain an active worksheet.
func GroupSheets(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		length := args[0].Length()
		var slice []string
		for i := 0; i < length; i++ {
			arg := args[0].Index(i)
			switch arg.Type() {
			case js.TypeString:
				slice = append(slice, arg.String())
			default:
			}
		}
		if err := f.GroupSheets(slice); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// InsertCols provides a function to insert new columns before the given column
// name and number of columns.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func InsertCols(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.InsertCols(args[0].String(), args[1].String(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// InsertPageBreak create a page break to determine where the printed page ends
// and where begins the next one by given worksheet name and cell, so the
// content before the page break will be printed on one page and after the
// page break on another.
func InsertPageBreak(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.InsertPageBreak(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// InsertRows provides a function to insert new rows after the given Excel
// row number starting from 1 and number of rows.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func InsertRows(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.InsertRows(args[0].String(), args[1].Int(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// MergeCell provides a function to merge cells by given range reference and
// sheet name. Merging cells only keeps the upper-left cell value, and
// discards the other values.
//
// If you create a merged cell that overlaps with another existing merged
// cell, those merged cells that already exist will be removed. The cell
// references tuple after merging in the following range will be: A1
// (x3,y1) D1(x2,y1) A8(x3,y4) D8(x2,y4)
//
//	             B1(x1,y1)      D1(x2,y1)
//	           +------------------------+
//	           |                        |
//	 A4(x3,y3) |    C4(x4,y3)           |
//	+------------------------+          |
//	|          |             |          |
//	|          |B5(x1,y2)    | D5(x2,y2)|
//	|          +------------------------+
//	|                        |
//	|A8(x3,y4)      C8(x4,y4)|
//	+------------------------+
func MergeCell(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.MergeCell(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// NewConditionalStyle provides a function to create style for conditional
// format by given style format. The parameters are the same with the
// NewStyle function. Note that the color field uses RGB color code and only
// support to set font, fills, alignment and borders currently.
func NewConditionalStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var style excelize.Style
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.Style{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		style = goVal.Elem().Interface().(excelize.Style)
		if ret["style"], err = f.NewConditionalStyle(&style); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// NewSheet provides the function to create a new sheet by given a worksheet
// name and returns the index of the sheets in the workbook after it appended.
// Note that when creating a new workbook, the default worksheet named
// `Sheet1` will be created.
func NewSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"index": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if ret["index"], err = f.NewSheet(args[0].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// NewStyle provides a function to create the style for cells by given options.
// Note that the color field uses RGB color code.
func NewStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"style": 0, "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var style excelize.Style
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.Style{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		style = goVal.Elem().Interface().(excelize.Style)
		if ret["style"], err = f.NewStyle(&style); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// ProtectSheet provides a function to prevent other users from accidentally or
// deliberately changing, moving, or deleting data in a worksheet. The
// optional field AlgorithmName specified hash algorithm, support XOR, MD4,
// MD5, SHA-1, SHA2-56, SHA-384, and SHA-512 currently, if no hash algorithm
// specified, will be using the XOR algorithm as default.
func ProtectSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.SheetProtectionOptions
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.SheetProtectionOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.SheetProtectionOptions)
		if err := f.ProtectSheet(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// ProtectWorkbook provides a function to prevent other users from viewing
// hidden worksheets, adding, moving, deleting, or hiding worksheets, and
// renaming worksheets in a workbook. The optional field AlgorithmName
// specified hash algorithm, support XOR, MD4, MD5, SHA-1, SHA2-56, SHA-384,
// and SHA-512 currently, if no hash algorithm specified, will be using the XOR
// algorithm as default. The generated workbook only works on Microsoft Office
// 2007 and later.
func ProtectWorkbook(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.WorkbookProtectionOptions
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.WorkbookProtectionOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.WorkbookProtectionOptions)
		if err := f.ProtectWorkbook(&opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// RemoveCol provides a function to remove single column by given worksheet
// name and column index.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func RemoveCol(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.RemoveCol(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// RemovePageBreak remove a page break by given worksheet name and cell
// reference.
func RemovePageBreak(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.RemovePageBreak(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// RemoveRow provides a function to remove single row by given worksheet name
// and Excel row number.
//
// Use this method with caution, which will affect changes in references such
// as formulas, charts, and so on. If there is any referenced value of the
// worksheet, it will cause a file error when you open it. The excelize only
// partially updates these references currently.
func RemoveRow(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.RemoveRow(args[0].String(), args[1].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SearchSheet provides a function to get cell reference by given worksheet
// name, cell value, and regular expression. The function doesn't support
// searching on the calculated result, formatted numbers and conditional
// lookup currently. If it is a merged cell, it will return the cell reference
// of the upper left cell of the merged range reference.
func SearchSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"result": js.ValueOf([]interface{}{}), "error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}, opts: true},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var reg bool
		if len(args) == 3 {
			reg = args[2].Bool()
		}
		result, err := f.SearchSheet(args[0].String(), args[1].String(), reg)
		if err != nil {
			ret["error"] = err.Error()
		}
		excepted := make([]interface{}, len(result))
		for i, cell := range result {
			excepted[i] = cell
		}
		ret["result"] = excepted
		return js.ValueOf(ret)
	}
}

// SetActiveSheet provides a function to set the default active sheet of the
// workbook by a given index. Note that the active index is different from the
// ID returned by function GetSheetMap(). It should be greater than or equal
// to 0 and less than the total worksheet numbers.
func SetActiveSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		f.SetActiveSheet(args[0].Int())
		return js.ValueOf(ret)
	}
}

// SetAppProps provides a function to set document application properties.
func SetAppProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var props excelize.AppProperties
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.AppProperties{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props = goVal.Elem().Interface().(excelize.AppProperties)
		if err := f.SetAppProps(&props); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellBool provides a function to set bool type value of a cell by given
// worksheet name, cell reference and cell value.
func SetCellBool(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellBool(args[0].String(), args[1].String(), args[2].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellDefault provides a function to set string type value of a cell as
// default format without escaping the cell.
func SetCellDefault(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellDefault(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellFloat sets a floating point value into a cell. The precision
// parameter specifies how many places after the decimal will be shown
// while -1 is a special value that will use as many decimal places as
// necessary to represent the number. bitSize is 32 or 64 depending on if a
// float32 or float64 was originally used for the value.
func SetCellFloat(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellFloat(args[0].String(), args[1].String(), args[2].Float(), args[3].Int(), args[4].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellFormula provides a function to set formula on the cell is taken
// according to the given worksheet name and cell formula settings. The result
// of the formula cell can be calculated when the worksheet is opened by the
// Office Excel application or can be using the "CalcCellValue" function also
// can get the calculated cell value. If the Excel application doesn't
// calculate the formula automatically when the workbook has been opened,
// please call "UpdateLinkedValue" after setting the cell formula functions.
func SetCellFormula(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.FormulaOpts
		if len(args) == 4 {
			goVal, err := jsValueToGo(args[3], reflect.TypeOf(excelize.FormulaOpts{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = goVal.Elem().Interface().(excelize.FormulaOpts)
		}
		if err := f.SetCellFormula(args[0].String(), args[1].String(), args[2].String(), opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellHyperLink provides a function to set cell hyperlink by given
// worksheet name and link URL address. LinkType defines two types of
// hyperlink "External" for website or "Location" for moving to one of cell in
// this workbook. Maximum limit hyperlinks in a worksheet is 65530. This
// function is only used to set the hyperlink of the cell and doesn't affect
// the value of the cell. If you need to set the value of the cell, please use
// the other functions such as `SetCellStyle` or `SetSheetRow`.
func SetCellHyperLink(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}, opts: true},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.HyperlinkOpts
		if len(args) == 5 {
			goVal, err := jsValueToGo(args[4], reflect.TypeOf(excelize.HyperlinkOpts{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = goVal.Elem().Interface().(excelize.HyperlinkOpts)
		}
		if err := f.SetCellHyperLink(args[0].String(), args[1].String(), args[2].String(), args[3].String(), opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellInt provides a function to set int type value of a cell by given
// worksheet name, cell reference and cell value.
func SetCellInt(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellInt(args[0].String(), args[1].String(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellRichText provides a function to set cell with rich text by given
// worksheet.
func SetCellRichText(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var runs []excelize.RichTextRun
		for i := 0; i < args[2].Length(); i++ {
			goVal, err := jsValueToGo(args[2].Index(i), reflect.TypeOf(excelize.RichTextRun{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			runs = append(runs, goVal.Elem().Interface().(excelize.RichTextRun))
		}
		if err := f.SetCellRichText(args[0].String(), args[1].String(), runs); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellStr provides a function to set string type value of a cell. Total
// number of characters that a cell can contain 32767 characters.
func SetCellStr(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellStr(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellStyle provides a function to add style attribute for cells by given
// worksheet name, range reference and style ID. Note that diagonalDown and
// diagonalUp type border should be use same color in the same range.
// SetCellStyle will overwrite the existing styles for the cell, it won't
// append or merge style with existing styles.
func SetCellStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetCellStyle(args[0].String(), args[1].String(), args[2].String(), args[3].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetCellValue provides a function to set the value of a cell. The specified
// coordinates should not be in the first row of the table, a complex number
// can be set with string text.
//
// You can set numbers format by the SetCellStyle function. If you need to set
// the specialized date in Excel like January 0, 1900 or February 29, 1900.
// Please set the cell value as number 0 or 60, then create and bind the
// date-time number format style for the cell.
func SetCellValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean, js.TypeNumber, js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var value interface{}
		switch args[2].Type() {
		case js.TypeBoolean:
			value = args[2].Bool()
		case js.TypeNumber:
			value = args[2].Float()
		case js.TypeString:
			value = args[2].String()
		default:
		}
		if err := f.SetCellValue(args[0].String(), args[1].String(), value); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColOutlineLevel provides a function to set outline level of a single
// column by given worksheet name and column name. The value of parameter
// 'level' is 1-7.
func SetColOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColOutlineLevel(args[0].String(), args[1].String(), uint8(args[2].Int())); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColStyle provides a function to set style of columns by given worksheet
// name, columns range and style ID. Note that this will overwrite the
// existing styles for the columns, it won't append or merge style with
// existing styles.
func SetColStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColStyle(args[0].String(), args[1].String(), args[2].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColVisible provides a function to set visible columns by given worksheet
// name, columns range and visibility.
func SetColVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColVisible(args[0].String(), args[1].String(), args[2].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetColWidth provides a function to set the width of a single column or
// multiple columns.
func SetColWidth(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetColWidth(args[0].String(), args[1].String(), args[2].String(), args[3].Float()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetConditionalFormat provides a function to create conditional formatting
// rule for cell value. Conditional formatting is a feature of Excel which
// allows you to apply a format to a cell or a range of cells based on certain
// criteria.
func SetConditionalFormat(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts []excelize.ConditionalFormatOptions
		for i := 0; i < args[2].Length(); i++ {
			goVal, err := jsValueToGo(args[2].Index(i), reflect.TypeOf(excelize.ConditionalFormatOptions{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = append(opts, goVal.Elem().Interface().(excelize.ConditionalFormatOptions))
		}
		if err := f.SetConditionalFormat(args[0].String(), args[1].String(), opts); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetDefaultFont changes the default font in the workbook.
func SetDefaultFont(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{{types: []js.Type{js.TypeString}}}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetDefaultFont(args[0].String()); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetDefinedName provides a function to set the defined names of the workbook
// or worksheet. If not specified scope, the default scope is workbook.
func SetDefinedName(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var definedName excelize.DefinedName
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.DefinedName{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		definedName = goVal.Elem().Interface().(excelize.DefinedName)
		if err = f.SetDefinedName(&definedName); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetDocProps provides a function to set document core properties.
func SetDocProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var props excelize.DocProperties
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.DocProperties{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props = goVal.Elem().Interface().(excelize.DocProperties)
		if err = f.SetDocProps(&props); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetHeaderFooter provides a function to set headers and footers by given
// worksheet name and the control characters.
func SetHeaderFooter(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.HeaderFooterOptions
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.HeaderFooterOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.HeaderFooterOptions)
		if err = f.SetHeaderFooter(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetPageLayout provides a function to sets worksheet page layout.
func SetPageLayout(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.PageLayoutOptions
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.PageLayoutOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.PageLayoutOptions)
		if err = f.SetPageLayout(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetPageMargins provides a function to set worksheet page margins.
func SetPageMargins(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.PageLayoutMarginsOptions
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.PageLayoutMarginsOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.PageLayoutMarginsOptions)
		if err = f.SetPageMargins(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetPanes provides a function to create and remove freeze panes and split
// panes by given worksheet name and panes format set.
func SetPanes(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var panes excelize.Panes
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.Panes{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		panes = goVal.Elem().Interface().(excelize.Panes)
		if err := f.SetPanes(args[0].String(), &panes); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowHeight provides a function to set the height of a single row. If the
// value of height is 0, will hide the specified row, if the value of height is
// -1, will unset the custom row height.
func SetRowHeight(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowHeight(args[0].String(), args[1].Int(), args[2].Float()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowOutlineLevel provides a function to set outline level number of a
// single row by given worksheet name and Excel row number. The value of
// parameter 'level' is 1-7.
func SetRowOutlineLevel(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowOutlineLevel(args[0].String(), args[1].Int(), uint8(args[2].Int())); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowStyle provides a function to set the style of rows by given worksheet
// name, row range, and style ID. Note that this will overwrite the existing
// styles for the rows, it won't append or merge style with existing styles.
func SetRowStyle(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeNumber}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowStyle(args[0].String(), args[1].Int(), args[2].Int(), args[3].Int()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetRowVisible provides a function to set visible of a single row by given
// worksheet name and Excel row number.
func SetRowVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetRowVisible(args[0].String(), args[1].Int(), args[2].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetBackgroundFromBytes provides a function to set background picture by
// given worksheet name, extension name and image data. Supported image types:
// BMP, EMF, EMZ, GIF, JPEG, JPG, PNG, SVG, TIF, TIFF, WMF, and WMZ.
func SetSheetBackgroundFromBytes(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		buf := make([]byte, args[2].Get("length").Int())
		js.CopyBytesToGo(buf, args[2])
		if err := f.SetSheetBackgroundFromBytes(args[0].String(), args[1].String(), buf); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetCol writes an array to column by given worksheet name, starting cell
// reference and a pointer to array type 'slice'.
func SetSheetCol(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		length := args[2].Length()
		slice := make([]interface{}, length)
		for i := 0; i < length; i++ {
			arg := args[2].Index(i)
			switch arg.Type() {
			case js.TypeBoolean:
				slice[i] = arg.Bool()
			case js.TypeNumber:
				slice[i] = arg.Float()
			case js.TypeString:
				slice[i] = arg.String()
			default:
			}
		}
		if err := f.SetSheetCol(args[0].String(), args[1].String(), &slice); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetName provides a function to set the worksheet name by given source
// and target worksheet names. Maximum 31 characters are allowed in sheet
// title and this function only changes the name of the sheet and will not
// update the sheet name in the formula or reference associated with the cell.
// So there may be problem formula error or reference missing.
func SetSheetName(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetSheetName(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetProps provides a function to set worksheet properties.
func SetSheetProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.SheetPropsOptions
		goVal, err := jsValueToGo(args[1], reflect.TypeOf(excelize.SheetPropsOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.SheetPropsOptions)
		if err = f.SetSheetProps(args[0].String(), &opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetSheetRow writes an array to row by given worksheet name, starting cell
// reference and a pointer to array type 'slice'.
func SetSheetRow(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeObject}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		length := args[2].Length()
		var slice []interface{}
		for i := 0; i < length; i++ {
			arg := args[2].Index(i)
			switch arg.Type() {
			case js.TypeBoolean:
				slice = append(slice, arg.Bool())
			case js.TypeNumber:
				slice = append(slice, arg.Float())
			case js.TypeString:
				slice = append(slice, arg.String())
			default:
				slice = append(slice, nil)
			}
		}
		if err := f.SetSheetRow(args[0].String(), args[1].String(), &slice); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetSheetView sets sheet view options. The viewIndex may be negative and if
// so is counted backward (-1 is the last view).
func SetSheetView(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeNumber}},
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.ViewOptions
		goVal, err := jsValueToGo(args[2], reflect.TypeOf(excelize.ViewOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		opts = goVal.Elem().Interface().(excelize.ViewOptions)
		if err = f.SetSheetView(args[0].String(), args[1].Int(), &opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// SetSheetVisible provides a function to set worksheet visible by given
// worksheet name. A workbook must contain at least one visible worksheet. If
// the given worksheet has been activated, this setting will be invalidated.
func SetSheetVisible(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeBoolean}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.SetSheetVisible(args[0].String(), args[1].Bool()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// SetWorkbookProps provides a function to sets workbook properties.
func SetWorkbookProps(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var props excelize.WorkbookPropsOptions
		goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.WorkbookPropsOptions{}))
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		props = goVal.Elem().Interface().(excelize.WorkbookPropsOptions)
		if err = f.SetWorkbookProps(&props); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// UngroupSheets provides a function to ungroup worksheets.
func UngroupSheets(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.UngroupSheets(); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UnmergeCell provides a function to unmerge a given range reference.
func UnmergeCell(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.UnmergeCell(args[0].String(), args[1].String(), args[2].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UnprotectSheet provides a function to remove protection for a sheet,
// specified the second optional password parameter to remove sheet protection
// with password verification.
func UnprotectSheet(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if len(args) == 2 {
			err = f.UnprotectSheet(args[0].String(), args[1].String())
		} else {
			err = f.UnprotectSheet(args[0].String())
		}
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UnprotectWorkbook provides a function to remove protection for workbook,
// specified the optional password parameter to remove workbook protection with
// password verification.
func UnprotectWorkbook(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if len(args) == 1 {
			err = f.UnprotectWorkbook(args[0].String())
		} else {
			err = f.UnprotectWorkbook()
		}
		if err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UnsetConditionalFormat provides a function to unset the conditional format
// by given worksheet name and range reference.
func UnsetConditionalFormat(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeString}},
			{types: []js.Type{js.TypeString}},
		}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.UnsetConditionalFormat(args[0].String(), args[1].String()); err != nil {
			ret["error"] = err.Error()
		}
		return js.ValueOf(ret)
	}
}

// UpdateLinkedValue fix linked values within a spreadsheet are not updating in
// Office Excel application. This function will be remove value tag when met a
// cell have a linked value.
func UpdateLinkedValue(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"error": nil}
		if err := prepareArgs(args, []argsRule{}); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		if err := f.UpdateLinkedValue(); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		return js.ValueOf(ret)
	}
}

// WriteToBuffer provides a function to get the contents buffer from the saved
// file, and it allocates space in memory. Be careful when the file size is
// large.
func WriteToBuffer(f *excelize.File) func(this js.Value, args []js.Value) interface{} {
	return func(this js.Value, args []js.Value) interface{} {
		ret := map[string]interface{}{"buffer": js.ValueOf([]interface{}{}), "error": nil}
		err := prepareArgs(args, []argsRule{
			{types: []js.Type{js.TypeObject}, opts: true},
		})
		if err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		var opts excelize.Options
		if len(args) == 1 {
			goVal, err := jsValueToGo(args[0], reflect.TypeOf(excelize.Options{}))
			if err != nil {
				ret["error"] = err.Error()
				return js.ValueOf(ret)
			}
			opts = goVal.Elem().Interface().(excelize.Options)
		}
		buf := new(bytes.Buffer)
		if err := f.Write(buf, opts); err != nil {
			ret["error"] = err.Error()
			return js.ValueOf(ret)
		}
		src := buf.Bytes()
		dst := js.Global().Get("Uint8Array").New(len(src))
		js.CopyBytesToJS(dst, src)
		ret["buffer"] = dst
		return js.ValueOf(ret)
	}
}
